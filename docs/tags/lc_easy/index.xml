<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>lc_easy on Siwei&#39;s Blog</title>
    <link>https://blog.siwei.dev/tags/lc_easy/</link>
    <description>Recent content in lc_easy on Siwei&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 30 Sep 2021 00:00:00 -0400</lastBuildDate><atom:link href="https://blog.siwei.dev/tags/lc_easy/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>1 Two Sum</title>
      <link>https://blog.siwei.dev/leetcode/1-two-sum/</link>
      <pubDate>Mon, 21 Sep 2020 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/1-two-sum/</guid>
      <description>Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.
You may assume that each input would have exactly one solution, and you may not use the same element twice.
You can return the answer in any order.
Example 1:
Input: nums = [2,7,11,15], target = 9 Output: [0,1] Output: Because nums[0] + nums[1] == 9, we return [0, 1].</description>
    </item>
    
    <item>
      <title>20 Valid Parentheses</title>
      <link>https://blog.siwei.dev/leetcode/20-valid-parentheses/</link>
      <pubDate>Fri, 25 Sep 2020 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/20-valid-parentheses/</guid>
      <description>Given a string s containing just the characters &#39;(&#39;, &#39;)&#39;, &#39;{&#39;, &#39;}&#39;, &#39;[&#39; and &#39;]&#39;, determine if the input string is valid.
An input string is valid if:
 Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order.  Example 1:
Input: s = &amp;quot;()&amp;quot; Output: true Example 2:
Input: s = &amp;quot;()[]{}&amp;quot; Output: true Example 3:
Input: s = &amp;quot;(]&amp;quot; Output: false Example 4:</description>
    </item>
    
    <item>
      <title>21 Merge Two Sorted Lists</title>
      <link>https://blog.siwei.dev/leetcode/21-merge-two-sorted-lists/</link>
      <pubDate>Sun, 18 Oct 2020 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/21-merge-two-sorted-lists/</guid>
      <description>Merge two sorted linked lists and return it as a new sorted list. The new list should be made by splicing together the nodes of the first two lists.
Example 1:
Input: l1 = [1,2,4], l2 = [1,3,4] Output: [1,1,2,3,4,4] Example 2:
Input: l1 = [], l2 = [] Output: [] Example 3:
Input: l1 = [], l2 = [0] Output: [0] Constraints:
 The number of nodes in both lists is in the range [0, 50].</description>
    </item>
    
    <item>
      <title>35 Search Insert Position</title>
      <link>https://blog.siwei.dev/leetcode/35-search-insert-position/</link>
      <pubDate>Sat, 18 Sep 2021 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/35-search-insert-position/</guid>
      <description>Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.
You must write an algorithm with O(log n) runtime complexity.
Example 1:
Input: nums = [1,3,5,6], target = 5 Output: 2 Example 2:
Input: nums = [1,3,5,6], target = 2 Output: 1 Example 3:
Input: nums = [1,3,5,6], target = 7 Output: 4 Example 4:</description>
    </item>
    
    <item>
      <title>53 Maximum Subarray</title>
      <link>https://blog.siwei.dev/leetcode/53-maximum-subarray/</link>
      <pubDate>Sun, 19 Sep 2021 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/53-maximum-subarray/</guid>
      <description>Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.
A subarray is a contiguous part of an array.
Example 1:
Input: nums = [-2,1,-3,4,-1,2,1,-5,4] Output: 6 Explanation: [4,-1,2,1] has the largest sum = 6. Example 2:
Input: nums = [1] Output: 1 Example 3:
Input: nums = [5,4,-1,7,8] Output: 23 Constraints:
 1 &amp;lt;= nums.length &amp;lt;= 3 * 104 -105 &amp;lt;= nums[i] &amp;lt;= 105  Follow up: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.</description>
    </item>
    
    <item>
      <title>70 Climbing Stairs</title>
      <link>https://blog.siwei.dev/leetcode/70-climbing-stairs/</link>
      <pubDate>Tue, 21 Sep 2021 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/70-climbing-stairs/</guid>
      <description>You are climbing a staircase. It takes n steps to reach the top.
Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?
Example 1:
Input: n = 2 Output: 2 Explanation: There are two ways to climb to the top. 1. 1 step + 1 step 2. 2 steps Example 2:
Input: n = 3 Output: 3 Explanation: There are three ways to climb to the top.</description>
    </item>
    
    <item>
      <title>88 Merge Sorted Array</title>
      <link>https://blog.siwei.dev/leetcode/88-merge-sorted-array/</link>
      <pubDate>Tue, 21 Sep 2021 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/88-merge-sorted-array/</guid>
      <description>You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.
Merge nums1 and nums2 into a single array sorted in non-decreasing order.
The final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored.</description>
    </item>
    
    <item>
      <title>100 Same Tree</title>
      <link>https://blog.siwei.dev/leetcode/100-same-tree/</link>
      <pubDate>Wed, 09 Jun 2021 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/100-same-tree/</guid>
      <description>Given the roots of two binary trees p and q, write a function to check if they are the same or not.
Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.
Example 1:
 1 1 / \ / \ 2 3 2 3 Input: p = [1,2,3], q = [1,2,3] Output: true Example 2:
 1 1 / \ 2 2 Input: p = [1,2], q = [1,null,2] Output: false Example 3:</description>
    </item>
    
    <item>
      <title>101 Symmetric Tree</title>
      <link>https://blog.siwei.dev/leetcode/101-symmetric-tree/</link>
      <pubDate>Sat, 20 Mar 2021 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/101-symmetric-tree/</guid>
      <description>Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).
Example 1:
 1 / \ 2 2 / \ / \ 3 4 4 3 Input: root = [1,2,2,3,4,4,3] Output: true Example 2:
 1 / \ 2 2 \ \ 3 3 Input: root = [1,2,2,null,3,null,3] Output: false Constraints:
 The number of nodes in the tree is in the range [1, 1000].</description>
    </item>
    
    <item>
      <title>118 Pascal&#39;s Triangle</title>
      <link>https://blog.siwei.dev/leetcode/118-pascals-triangle/</link>
      <pubDate>Thu, 30 Sep 2021 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/118-pascals-triangle/</guid>
      <description>Given an integer numRows, return the first numRows of Pascal&amp;rsquo;s triangle.
In Pascal&amp;rsquo;s triangle, each number is the sum of the two numbers directly above it as shown:
 1 1 1 1 2 1 1 3 3 1 1 4 6 4 1 Example 1:
Input: numRows = 5 Output: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]] Example 2:
Input: numRows = 1 Output: [[1]] Constraints:
 1 &amp;lt;= numRows &amp;lt;= 30   1 2 3 4 5 6 7 8 9 10 11 12 13  class Solution: def __init__(self): self.</description>
    </item>
    
    <item>
      <title>121 Best Time to Buy and Sell Stock</title>
      <link>https://blog.siwei.dev/leetcode/121-best-time-to-buy-and-sell-stock/</link>
      <pubDate>Thu, 23 Sep 2021 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/121-best-time-to-buy-and-sell-stock/</guid>
      <description>You are given an array prices where prices[i] is the price of a given stock on the ith day.
You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.
Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.
Example 1:
Input: prices = [7,1,5,3,6,4] Output: 5 Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.</description>
    </item>
    
    <item>
      <title>122 Best Time to Buy and Sell Stock II</title>
      <link>https://blog.siwei.dev/leetcode/122-best-time-to-buy-and-sell-stock-ii/</link>
      <pubDate>Sun, 25 Oct 2020 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/122-best-time-to-buy-and-sell-stock-ii/</guid>
      <description>Say you have an array prices for which the ith element is the price of a given stock on day i.
Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).
Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).</description>
    </item>
    
    <item>
      <title>136 Single Number</title>
      <link>https://blog.siwei.dev/leetcode/136-single-number/</link>
      <pubDate>Sat, 26 Sep 2020 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/136-single-number/</guid>
      <description>Given a non-empty array of integers, every element appears twice except for one. Find that single one.
Note:
Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?
Example 1:
Input: [2,2,1] Output: 1 Example 2:
Input: [4,1,2,1,2] Output: 4  1 2 3 4 5 6 7 8 9 10 11 12 13 14  func singleNumber(nums []int) int { set := make(map[int]bool) for _, num := range nums { if _, ok := set[num]; ok { delete(set, num) } else { set[num] = true } } for num, _ := range set { return num } return -1 }    https://runtime.</description>
    </item>
    
    <item>
      <title>167 Two Sum II - Input array is sorted</title>
      <link>https://blog.siwei.dev/leetcode/167-two-sum-ii-input-array-is-sorted/</link>
      <pubDate>Sat, 18 Sep 2021 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/167-two-sum-ii-input-array-is-sorted/</guid>
      <description>Given an array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number.
Return the indices of the two numbers (1-indexed) as an integer array answer of size 2, where 1 &amp;lt;= answer[0] &amp;lt; answer[1] &amp;lt;= numbers.length.
The tests are generated such that there is exactly one solution. You may not use the same element twice.
Example 1:</description>
    </item>
    
    <item>
      <title>189 Rotate Array</title>
      <link>https://blog.siwei.dev/leetcode/189-rotate-array/</link>
      <pubDate>Sat, 18 Sep 2021 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/189-rotate-array/</guid>
      <description>Given an array, rotate the array to the right by k steps, where k is non-negative.
Example 1:
Input: nums = [1,2,3,4,5,6,7], k = 3 Output: [5,6,7,1,2,3,4] Explanation: rotate 1 steps to the right: [7,1,2,3,4,5,6] rotate 2 steps to the right: [6,7,1,2,3,4,5] rotate 3 steps to the right: [5,6,7,1,2,3,4] Example 2:
Input: nums = [-1,-100,3,99], k = 2 Output: [3,99,-1,-100] Explanation: rotate 1 steps to the right: [99,-1,-100,3] rotate 2 steps to the right: [3,99,-1,-100] Constraints:</description>
    </item>
    
    <item>
      <title>217 Contains Duplicate</title>
      <link>https://blog.siwei.dev/leetcode/217-contains-duplicate/</link>
      <pubDate>Sun, 19 Sep 2021 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/217-contains-duplicate/</guid>
      <description>Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.
Example 1:
Input: nums = [1,2,3,1] Output: true Example 2:
Input: nums = [1,2,3,4] Output: false Example 3:
Input: nums = [1,1,1,3,3,4,3,2,4,2] Output: true Constraints:
 1 &amp;lt;= nums.length &amp;lt;= 105 -109 &amp;lt;= nums[i] &amp;lt;= 109   1 2 3  class Solution: def containsDuplicate(self, nums: List[int]) -&amp;gt; bool: return len(set(nums)) !</description>
    </item>
    
    <item>
      <title>231 Power of Two</title>
      <link>https://blog.siwei.dev/leetcode/231-power-of-two/</link>
      <pubDate>Tue, 20 Oct 2020 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/231-power-of-two/</guid>
      <description>Given an integer n, write a function to determine if it is a power of two.
Example 1:
Input: n = 1 Output: true Explanation: 20 = 1 Example 2:
Input: n = 16 Output: true Explanation: 24 = 16 Example 3:
Input: n = 3 Output: false Example 4:
Input: n = 4 Output: true Example 5:
Input: n = 5 Output: false Constraints:
 -231 &amp;lt;= n &amp;lt;= 231 - 1   1 2 3 4 5 6 7  func isPowerOfTwo(n int) bool { i := 1 for i &amp;lt; n { i *= 2 } return i == n }    https://runtime.</description>
    </item>
    
    <item>
      <title>242 Valid Anagram</title>
      <link>https://blog.siwei.dev/leetcode/242-valid-anagram/</link>
      <pubDate>Thu, 10 Dec 2020 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/242-valid-anagram/</guid>
      <description>Given two strings s and t , write a function to determine if t is an anagram of s.
Example 1:
Input: s = &amp;quot;anagram&amp;quot;, t = &amp;quot;nagaram&amp;quot; Output: true Example 2:
Input: s = &amp;quot;rat&amp;quot;, t = &amp;quot;car&amp;quot; Output: false Note: You may assume the string contains only lowercase alphabets.
Follow up: What if the inputs contain unicode characters? How would you adapt your solution to such case?
 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  func isAnagram(s string, t string) bool { if len(s) !</description>
    </item>
    
    <item>
      <title>278  First Bad Version</title>
      <link>https://blog.siwei.dev/leetcode/278-first-bad-version/</link>
      <pubDate>Fri, 17 Sep 2021 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/278-first-bad-version/</guid>
      <description>You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.
Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.</description>
    </item>
    
    <item>
      <title>283 Move Zeroes</title>
      <link>https://blog.siwei.dev/leetcode/283-move-zeroes/</link>
      <pubDate>Sat, 18 Sep 2021 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/283-move-zeroes/</guid>
      <description>Given an integer array nums, move all 0&amp;rsquo;s to the end of it while maintaining the relative order of the non-zero elements.
Note that you must do this in-place without making a copy of the array.
Example 1:
Input: nums = [0,1,0,3,12] Output: [1,3,12,0,0] Example 2:
Input: nums = [0] Output: [0] Constraints:
 1 &amp;lt;= nums.length &amp;lt;= 104 -231 &amp;lt;= nums[i] &amp;lt;= 231 - 1  Follow up: Could you minimize the total number of operations done?</description>
    </item>
    
    <item>
      <title>344 Reverse String</title>
      <link>https://blog.siwei.dev/leetcode/344-reverse-string/</link>
      <pubDate>Tue, 20 Oct 2020 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/344-reverse-string/</guid>
      <description>Write a function that reverses a string. The input string is given as an array of characters char[].
Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.
You may assume all the characters consist of printable ascii characters.
Example 1:
Input: [&amp;quot;h&amp;quot;,&amp;quot;e&amp;quot;,&amp;quot;l&amp;quot;,&amp;quot;l&amp;quot;,&amp;quot;o&amp;quot;] Output: [&amp;quot;o&amp;quot;,&amp;quot;l&amp;quot;,&amp;quot;l&amp;quot;,&amp;quot;e&amp;quot;,&amp;quot;h&amp;quot;] Example 2:
Input: [&amp;quot;H&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;n&amp;quot;,&amp;quot;n&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;h&amp;quot;] Output: [&amp;quot;h&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;n&amp;quot;,&amp;quot;n&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;H&amp;quot;]  1 2 3 4 5 6 7 8 9 10 11  func reverseString(s []byte]) { i , j := 0, len(s) - 1 for i &amp;lt; j { temp := s[i] s[i] = s[j] i++ s[j] = temp j-- } fmt.</description>
    </item>
    
    <item>
      <title>350 Intersection of Two Arrays II</title>
      <link>https://blog.siwei.dev/leetcode/350-intersection-of-two-arrays-ii/</link>
      <pubDate>Thu, 30 Sep 2021 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/350-intersection-of-two-arrays-ii/</guid>
      <description>Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays and you may return the result in any order.
Example 1:
Input: nums1 = [1,2,2,1], nums2 = [2,2] Output: [2,2] Example 2:
Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4] Output: [4,9] Explanation: [9,4] is also accepted. Constraints:
 1 &amp;lt;= nums1.length, nums2.</description>
    </item>
    
    <item>
      <title>387 First Unique Character in a String</title>
      <link>https://blog.siwei.dev/leetcode/387-first-unique-character-in-a-string/</link>
      <pubDate>Sun, 20 Dec 2020 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/387-first-unique-character-in-a-string/</guid>
      <description>Given a string, find the first non-repeating character in it and return its index. If it doesn&amp;rsquo;t exist, return -1.
Examples:
s = &amp;quot;leetcode&amp;quot; return 0. s = &amp;quot;loveleetcode&amp;quot; return 2. Note: You may assume the string contains only lowercase English letters.
 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  func firstUniqChar(s string) int { m := make(map[rune]int) for i, c := range s { _, has := m[c] if has { m[c] = -1 } else { m[c] = i } } const maxInt = int(^uint(0) &amp;gt;&amp;gt; 1) min := maxInt for _, i := range m { if i &amp;gt; -1 &amp;amp;&amp;amp; i &amp;lt; min { min = i } } if min == maxInt { return -1 } return min }     </description>
    </item>
    
    <item>
      <title>405 Convert a Number to Hexadecimal</title>
      <link>https://blog.siwei.dev/leetcode/405-convert-a-number-to-hexadecimal/</link>
      <pubDate>Tue, 30 Mar 2021 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/405-convert-a-number-to-hexadecimal/</guid>
      <description>Given an integer, write an algorithm to convert it to hexadecimal. For negative integer, two’s complement method is used.
Note:
All letters in hexadecimal (a-f) must be in lowercase. The hexadecimal string must not contain extra leading 0s. If the number is zero, it is represented by a single zero character &#39;0&#39;; otherwise, the first character in the hexadecimal string will not be the zero character. The given number is guaranteed to fit within the range of a 32-bit signed integer.</description>
    </item>
    
    <item>
      <title>412 Fizz Buzz</title>
      <link>https://blog.siwei.dev/leetcode/412-fizz-buzz/</link>
      <pubDate>Thu, 24 Sep 2020 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/412-fizz-buzz/</guid>
      <description>Write a program that outputs the string representation of numbers from 1 to n.
But for multiples of three it should output “Fizz” instead of the number and for the multiples of five output “Buzz”. For numbers which are multiples of both three and five output “FizzBuzz”.
Example:
n = 15, Return: [ &amp;quot;1&amp;quot;, &amp;quot;2&amp;quot;, &amp;quot;Fizz&amp;quot;, &amp;quot;4&amp;quot;, &amp;quot;Buzz&amp;quot;, &amp;quot;Fizz&amp;quot;, &amp;quot;7&amp;quot;, &amp;quot;8&amp;quot;, &amp;quot;Fizz&amp;quot;, &amp;quot;Buzz&amp;quot;, &amp;quot;11&amp;quot;, &amp;quot;Fizz&amp;quot;, &amp;quot;13&amp;quot;, &amp;quot;14&amp;quot;, &amp;quot;FizzBuzz&amp;quot; ]  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  func fizzBuzz(n int) []string { var result []string for i := 1; i &amp;lt;= n; i++ { if i%3 == 0 &amp;amp;&amp;amp; i%5 == 0 { result = append(result, &amp;#34;FizzBuzz&amp;#34;) } else if i%3 == 0 { result = append(result, &amp;#34;Fizz&amp;#34;) } else if i%5 == 0 { result = append(result, &amp;#34;Buzz&amp;#34;) } else { result = append(result, strconv.</description>
    </item>
    
    <item>
      <title>476 Number Complement</title>
      <link>https://blog.siwei.dev/leetcode/476-number-complement/</link>
      <pubDate>Thu, 10 Dec 2020 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/476-number-complement/</guid>
      <description>Given a positive integer num, output its complement number. The complement strategy is to flip the bits of its binary representation.
Example 1:
Input: num = 5 Output: 2 Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2. Example 2:
Input: num = 1 Output: 0 Explanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0.</description>
    </item>
    
    <item>
      <title>504 Base 7</title>
      <link>https://blog.siwei.dev/leetcode/504-base-7/</link>
      <pubDate>Tue, 08 Jun 2021 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/504-base-7/</guid>
      <description>Given an integer num, return a string of its base 7 representation.
Example 1:
Input: num = 100 Output: &amp;quot;202&amp;quot; Example 2:
Input: num = -7 Output: &amp;quot;-10&amp;quot; Constraints:
 -107 &amp;lt;= num &amp;lt;= 107   1 2 3 4 5 6 7 8 9  func convertToBase7(num int) string { if num &amp;lt; 0 { return &amp;#34;-&amp;#34; + convertToBase7(-num) } if num &amp;lt; 7 { return strconv.Itoa(num) } return convertToBase7(num/7) + strconv.</description>
    </item>
    
    <item>
      <title>509 Fibonacci Number</title>
      <link>https://blog.siwei.dev/leetcode/509-fibonacci-number/</link>
      <pubDate>Sun, 19 Sep 2021 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/509-fibonacci-number/</guid>
      <description>The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is,
F(0) = 0, F(1) = 1 F(n) = F(n - 1) + F(n - 2), for n &amp;gt; 1. Given n, calculate F(n).
Example 1:
Input: n = 2 Output: 1 Explanation: F(2) = F(1) + F(0) = 1 + 0 = 1.</description>
    </item>
    
    <item>
      <title>557 Reverse Words in a String III</title>
      <link>https://blog.siwei.dev/leetcode/557-reverse-words-in-a-string-iii/</link>
      <pubDate>Sun, 19 Sep 2021 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/557-reverse-words-in-a-string-iii/</guid>
      <description>Given a string s, reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.
Example 1:
Input: s = &amp;quot;Let&#39;s take LeetCode contest&amp;quot; Output: &amp;quot;s&#39;teL ekat edoCteeL tsetnoc&amp;quot; Example 2:
Input: s = &amp;quot;God Ding&amp;quot; Output: &amp;quot;doG gniD&amp;quot; Constraints:
 1 &amp;lt;= s.length &amp;lt;= 5 * 104 s contains printable ASCII characters. s does not contain any leading or trailing spaces. There is at least one word in s.</description>
    </item>
    
    <item>
      <title>566 Reshape the Matrix</title>
      <link>https://blog.siwei.dev/leetcode/566-reshape-the-matrix/</link>
      <pubDate>Thu, 30 Sep 2021 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/566-reshape-the-matrix/</guid>
      <description>In MATLAB, there is a handy function called reshape which can reshape an m x n matrix into a new one with a different size r x c keeping its original data.
You are given an m x n matrix mat and two integers r and c representing the number of rows and the number of columns of the wanted reshaped matrix.
The reshaped matrix should be filled with all the elements of the original matrix in the same row-traversing order as they were.</description>
    </item>
    
    <item>
      <title>617 Merge Two Binary Trees</title>
      <link>https://blog.siwei.dev/leetcode/617-merge-two-binary-trees/</link>
      <pubDate>Thu, 23 Sep 2021 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/617-merge-two-binary-trees/</guid>
      <description>You are given two binary trees root1 and root2.
Imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree.</description>
    </item>
    
    <item>
      <title>704 Binary Search</title>
      <link>https://blog.siwei.dev/leetcode/704-binary-search/</link>
      <pubDate>Sat, 18 Sep 2021 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/704-binary-search/</guid>
      <description>Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.
You must write an algorithm with O(log n) runtime complexity.
Example 1:
Input: nums = [-1,0,3,5,9,12], target = 9 Output: 4 Explanation: 9 exists in nums and its index is 4 Example 2:
Input: nums = [-1,0,3,5,9,12], target = 2 Output: -1 Explanation: 2 does not exist in nums so return -1 Constraints:</description>
    </item>
    
    <item>
      <title>733 Flood Fill</title>
      <link>https://blog.siwei.dev/leetcode/733-flood-fill/</link>
      <pubDate>Thu, 23 Sep 2021 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/733-flood-fill/</guid>
      <description>An image is represented by an m x n integer grid image where image[i][j] represents the pixel value of the image.
You are also given three integers sr, sc, and newColor. You should perform a flood fill on the image starting from the pixel image[sr][sc].
To perform a flood fill, consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color), and so on.</description>
    </item>
    
    <item>
      <title>876 Middle of the Linked List</title>
      <link>https://blog.siwei.dev/leetcode/876-middle-of-the-linked-list/</link>
      <pubDate>Sun, 19 Sep 2021 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/876-middle-of-the-linked-list/</guid>
      <description>Given the head of a singly linked list, return the middle node of the linked list.
If there are two middle nodes, return the second middle node.
Example 1:
1 -&amp;gt; 2 -&amp;gt; (3) -&amp;gt; 4 -&amp;gt; 5 Input: head = [1,2,3,4,5] Output: [3,4,5] Explanation: The middle node of the list is node 3. Example 2:
1 -&amp;gt; 2 -&amp;gt; 3 -&amp;gt; (4) -&amp;gt; 5 -&amp;gt; 6 Input: head = [1,2,3,4,5,6] Output: [4,5,6] Explanation: Since the list has two middle nodes with values 3 and 4, we return the second one.</description>
    </item>
    
    <item>
      <title>977 Squares of a Sorted Array</title>
      <link>https://blog.siwei.dev/leetcode/977-squares-of-a-sorted-array/</link>
      <pubDate>Sat, 18 Sep 2021 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/977-squares-of-a-sorted-array/</guid>
      <description>Given an integer array nums sorted in non-decreasing order, return an array of the squares of each number sorted in non-decreasing order.
Example 1:
Input: nums = [-4,-1,0,3,10] Output: [0,1,9,16,100] Explanation: After squaring, the array becomes [16,1,0,9,100]. After sorting, it becomes [0,1,9,16,100]. Example 2:
Input: nums = [-7,-3,2,3,11] Output: [4,9,9,49,121] Constraints:
 1 &amp;lt;= nums.length &amp;lt;= 104 -104 &amp;lt;= nums[i] &amp;lt;= 104 nums is sorted in non-decreasing order.  Follow up: Squaring each element and sorting the new array is very trivial, could you find an O(n) solution using a different approach?</description>
    </item>
    
    <item>
      <title>1022 Sum of Root To Leaf Binary Numbers</title>
      <link>https://blog.siwei.dev/leetcode/1022-sum-of-root-to-leaf-binary-numbers/</link>
      <pubDate>Wed, 24 Mar 2021 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/1022-sum-of-root-to-leaf-binary-numbers/</guid>
      <description>You are given the root of a binary tree where each node has a value 0 or 1. Each root-to-leaf path represents a binary number starting with the most significant bit. For example, if the path is 0 -&amp;gt; 1 -&amp;gt; 1 -&amp;gt; 0 -&amp;gt; 1, then this could represent 01101 in binary, which is 13.
For all leaves in the tree, consider the numbers represented by the path from the root to that leaf.</description>
    </item>
    
    <item>
      <title>1114 Print in Order</title>
      <link>https://blog.siwei.dev/leetcode/1114-print-in-order/</link>
      <pubDate>Mon, 22 Mar 2021 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/1114-print-in-order/</guid>
      <description>Suppose we have a class:
public class Foo { public void first() { print(&amp;quot;first&amp;quot;); } public void second() { print(&amp;quot;second&amp;quot;); } public void third() { print(&amp;quot;third&amp;quot;); } } The same instance of Foo will be passed to three different threads. Thread A will call first(), thread B will call second(), and thread C will call third(). Design a mechanism and modify the program to ensure that second() is executed after first(), and third() is executed after second().</description>
    </item>
    
    <item>
      <title>1137 N-th Tribonacci Number</title>
      <link>https://blog.siwei.dev/leetcode/1137-n-th-tribonacci-number/</link>
      <pubDate>Sun, 19 Sep 2021 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/1137-n-th-tribonacci-number/</guid>
      <description>The Tribonacci sequence Tn is defined as follows:
T0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n &amp;gt;= 0.
Given n, return the value of Tn.
Example 1:
Input: n = 4 Output: 4 Explanation: T_3 = 0 + 1 + 1 = 2 T_4 = 1 + 1 + 2 = 4 Example 2:
Input: n = 25 Output: 1389537 Constraints:</description>
    </item>
    
    <item>
      <title>1413 Minimum Value to Get Positive Step by Step Sum</title>
      <link>https://blog.siwei.dev/leetcode/1413-minimum-value-to-get-positive-step-by-step-sum/</link>
      <pubDate>Sun, 28 Mar 2021 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/1413-minimum-value-to-get-positive-step-by-step-sum/</guid>
      <description>Given an array of integers nums, you start with an initial positive value startValue.
In each iteration, you calculate the step by step sum of startValue plus elements in nums (from left to right).
Return the minimum positive value of startValue such that the step by step sum is never less than 1.
Example 1:
Input: nums = [-3,2,-3,4,2] Output: 5 Explanation: If you choose startValue = 4, in the third iteration your step by step sum is less than 1.</description>
    </item>
    
  </channel>
</rss>
