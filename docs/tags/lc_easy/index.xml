<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>lc_easy on Siwei&#39;s Blog</title>
    <link>https://blog.siwei.dev/tags/lc_easy/</link>
    <description>Recent content in lc_easy on Siwei&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 09 Jun 2021 00:00:00 +0800</lastBuildDate><atom:link href="https://blog.siwei.dev/tags/lc_easy/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>1 Two Sum</title>
      <link>https://blog.siwei.dev/leetcode/1-two-sum/</link>
      <pubDate>Mon, 21 Sep 2020 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/1-two-sum/</guid>
      <description>Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.
You may assume that each input would have exactly one solution, and you may not use the same element twice.
You can return the answer in any order.
Example 1:
Input: nums = [2,7,11,15], target = 9 Output: [0,1] Output: Because nums[0] + nums[1] == 9, we return [0, 1].</description>
    </item>
    
    <item>
      <title>20 Valid Parentheses</title>
      <link>https://blog.siwei.dev/leetcode/20-valid-parentheses/</link>
      <pubDate>Fri, 25 Sep 2020 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/20-valid-parentheses/</guid>
      <description>Given a string s containing just the characters &#39;(&#39;, &#39;)&#39;, &#39;{&#39;, &#39;}&#39;, &#39;[&#39; and &#39;]&#39;, determine if the input string is valid.
An input string is valid if:
 Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order.  Example 1:
Input: s = &amp;quot;()&amp;quot; Output: true Example 2:
Input: s = &amp;quot;()[]{}&amp;quot; Output: true Example 3:
Input: s = &amp;quot;(]&amp;quot; Output: false Example 4:</description>
    </item>
    
    <item>
      <title>21 Merge Two Sorted Lists</title>
      <link>https://blog.siwei.dev/leetcode/21-merge-two-sorted-lists/</link>
      <pubDate>Sun, 18 Oct 2020 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/21-merge-two-sorted-lists/</guid>
      <description>Merge two sorted linked lists and return it as a new sorted list. The new list should be made by splicing together the nodes of the first two lists.
Example 1:
Input: l1 = [1,2,4], l2 = [1,3,4] Output: [1,1,2,3,4,4] Example 2:
Input: l1 = [], l2 = [] Output: [] Example 3:
Input: l1 = [], l2 = [0] Output: [0] Constraints:
 The number of nodes in both lists is in the range [0, 50].</description>
    </item>
    
    <item>
      <title>100 Same Tree</title>
      <link>https://blog.siwei.dev/leetcode/100-same-tree/</link>
      <pubDate>Wed, 09 Jun 2021 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/100-same-tree/</guid>
      <description>Given the roots of two binary trees p and q, write a function to check if they are the same or not.
Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.
Example 1:
 1 1 / \ / \ 2 3 2 3 Input: p = [1,2,3], q = [1,2,3] Output: true Example 2:
 1 1 / \ 2 2 Input: p = [1,2], q = [1,null,2] Output: false Example 3:</description>
    </item>
    
    <item>
      <title>101 Symmetric Tree</title>
      <link>https://blog.siwei.dev/leetcode/101-symmetric-tree/</link>
      <pubDate>Sat, 20 Mar 2021 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/101-symmetric-tree/</guid>
      <description>Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).
Example 1:
 1 / \ 2 2 / \ / \ 3 4 4 3 Input: root = [1,2,2,3,4,4,3] Output: true Example 2:
 1 / \ 2 2 \ \ 3 3 Input: root = [1,2,2,null,3,null,3] Output: false Constraints:
 The number of nodes in the tree is in the range [1, 1000].</description>
    </item>
    
    <item>
      <title>122 Best Time to Buy and Sell Stock II</title>
      <link>https://blog.siwei.dev/leetcode/122-best-time-to-buy-and-sell-stock-ii/</link>
      <pubDate>Sun, 25 Oct 2020 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/122-best-time-to-buy-and-sell-stock-ii/</guid>
      <description>Say you have an array prices for which the ith element is the price of a given stock on day i.
Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).
Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).</description>
    </item>
    
    <item>
      <title>136 Single Number</title>
      <link>https://blog.siwei.dev/leetcode/136-single-number/</link>
      <pubDate>Sat, 26 Sep 2020 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/136-single-number/</guid>
      <description>Given a non-empty array of integers, every element appears twice except for one. Find that single one.
Note:
Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?
Example 1:
Input: [2,2,1] Output: 1 Example 2:
Input: [4,1,2,1,2] Output: 4  1 2 3 4 5 6 7 8 9 10 11 12 13 14  func singleNumber(nums []int) int { set := make(map[int]bool) for _, num := range nums { if _, ok := set[num]; ok { delete(set, num) } else { set[num] = true } } for num, _ := range set { return num } return -1 }    https://runtime.</description>
    </item>
    
    <item>
      <title>231 Power of Two</title>
      <link>https://blog.siwei.dev/leetcode/231-power-of-two/</link>
      <pubDate>Tue, 20 Oct 2020 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/231-power-of-two/</guid>
      <description>Given an integer n, write a function to determine if it is a power of two.
Example 1:
Input: n = 1 Output: true Explanation: 20 = 1 Example 2:
Input: n = 16 Output: true Explanation: 24 = 16 Example 3:
Input: n = 3 Output: false Example 4:
Input: n = 4 Output: true Example 5:
Input: n = 5 Output: false Constraints:
 -231 &amp;lt;= n &amp;lt;= 231 - 1   1 2 3 4 5 6 7  func isPowerOfTwo(n int) bool { i := 1 for i &amp;lt; n { i *= 2 } return i == n }    https://runtime.</description>
    </item>
    
    <item>
      <title>242 Valid Anagram</title>
      <link>https://blog.siwei.dev/leetcode/242-valid-anagram/</link>
      <pubDate>Thu, 10 Dec 2020 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/242-valid-anagram/</guid>
      <description>Given two strings s and t , write a function to determine if t is an anagram of s.
Example 1:
Input: s = &amp;quot;anagram&amp;quot;, t = &amp;quot;nagaram&amp;quot; Output: true Example 2:
Input: s = &amp;quot;rat&amp;quot;, t = &amp;quot;car&amp;quot; Output: false Note: You may assume the string contains only lowercase alphabets.
Follow up: What if the inputs contain unicode characters? How would you adapt your solution to such case?
 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  func isAnagram(s string, t string) bool { if len(s) !</description>
    </item>
    
    <item>
      <title>344 Reverse String</title>
      <link>https://blog.siwei.dev/leetcode/344-reverse-string/</link>
      <pubDate>Tue, 20 Oct 2020 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/344-reverse-string/</guid>
      <description>Write a function that reverses a string. The input string is given as an array of characters char[].
Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.
You may assume all the characters consist of printable ascii characters.
Example 1:
Input: [&amp;quot;h&amp;quot;,&amp;quot;e&amp;quot;,&amp;quot;l&amp;quot;,&amp;quot;l&amp;quot;,&amp;quot;o&amp;quot;] Output: [&amp;quot;o&amp;quot;,&amp;quot;l&amp;quot;,&amp;quot;l&amp;quot;,&amp;quot;e&amp;quot;,&amp;quot;h&amp;quot;] Example 2:
Input: [&amp;quot;H&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;n&amp;quot;,&amp;quot;n&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;h&amp;quot;] Output: [&amp;quot;h&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;n&amp;quot;,&amp;quot;n&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;H&amp;quot;]  1 2 3 4 5 6 7 8 9 10 11  func reverseString(s []byte]) { i , j := 0, len(s) - 1 for i &amp;lt; j { temp := s[i] s[i] = s[j] i++ s[j] = temp j-- } fmt.</description>
    </item>
    
    <item>
      <title>387 First Unique Character in a String</title>
      <link>https://blog.siwei.dev/leetcode/387-first-unique-character-in-a-string/</link>
      <pubDate>Sun, 20 Dec 2020 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/387-first-unique-character-in-a-string/</guid>
      <description>Given a string, find the first non-repeating character in it and return its index. If it doesn&amp;rsquo;t exist, return -1.
Examples:
s = &amp;quot;leetcode&amp;quot; return 0. s = &amp;quot;loveleetcode&amp;quot; return 2. Note: You may assume the string contains only lowercase English letters.
 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  func firstUniqChar(s string) int { m := make(map[rune]int) for i, c := range s { _, has := m[c] if has { m[c] = -1 } else { m[c] = i } } const maxInt = int(^uint(0) &amp;gt;&amp;gt; 1) min := maxInt for _, i := range m { if i &amp;gt; -1 &amp;amp;&amp;amp; i &amp;lt; min { min = i } } if min == maxInt { return -1 } return min }     </description>
    </item>
    
    <item>
      <title>405 Convert a Number to Hexadecimal</title>
      <link>https://blog.siwei.dev/leetcode/405-convert-a-number-to-hexadecimal/</link>
      <pubDate>Tue, 30 Mar 2021 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/405-convert-a-number-to-hexadecimal/</guid>
      <description>Given an integer, write an algorithm to convert it to hexadecimal. For negative integer, two’s complement method is used.
Note:
All letters in hexadecimal (a-f) must be in lowercase. The hexadecimal string must not contain extra leading 0s. If the number is zero, it is represented by a single zero character &#39;0&#39;; otherwise, the first character in the hexadecimal string will not be the zero character. The given number is guaranteed to fit within the range of a 32-bit signed integer.</description>
    </item>
    
    <item>
      <title>412 Fizz Buzz</title>
      <link>https://blog.siwei.dev/leetcode/412-fizz-buzz/</link>
      <pubDate>Thu, 24 Sep 2020 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/412-fizz-buzz/</guid>
      <description>Write a program that outputs the string representation of numbers from 1 to n.
But for multiples of three it should output “Fizz” instead of the number and for the multiples of five output “Buzz”. For numbers which are multiples of both three and five output “FizzBuzz”.
Example:
n = 15, Return: [ &amp;quot;1&amp;quot;, &amp;quot;2&amp;quot;, &amp;quot;Fizz&amp;quot;, &amp;quot;4&amp;quot;, &amp;quot;Buzz&amp;quot;, &amp;quot;Fizz&amp;quot;, &amp;quot;7&amp;quot;, &amp;quot;8&amp;quot;, &amp;quot;Fizz&amp;quot;, &amp;quot;Buzz&amp;quot;, &amp;quot;11&amp;quot;, &amp;quot;Fizz&amp;quot;, &amp;quot;13&amp;quot;, &amp;quot;14&amp;quot;, &amp;quot;FizzBuzz&amp;quot; ]  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  func fizzBuzz(n int) []string { var result []string for i := 1; i &amp;lt;= n; i++ { if i%3 == 0 &amp;amp;&amp;amp; i%5 == 0 { result = append(result, &amp;#34;FizzBuzz&amp;#34;) } else if i%3 == 0 { result = append(result, &amp;#34;Fizz&amp;#34;) } else if i%5 == 0 { result = append(result, &amp;#34;Buzz&amp;#34;) } else { result = append(result, strconv.</description>
    </item>
    
    <item>
      <title>476 Number Complement</title>
      <link>https://blog.siwei.dev/leetcode/476-number-complement/</link>
      <pubDate>Thu, 10 Dec 2020 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/476-number-complement/</guid>
      <description>Given a positive integer num, output its complement number. The complement strategy is to flip the bits of its binary representation.
Example 1:
Input: num = 5 Output: 2 Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2. Example 2:
Input: num = 1 Output: 0 Explanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0.</description>
    </item>
    
    <item>
      <title>504 Base 7</title>
      <link>https://blog.siwei.dev/leetcode/504-base-7/</link>
      <pubDate>Tue, 08 Jun 2021 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/504-base-7/</guid>
      <description>Given an integer num, return a string of its base 7 representation.
Example 1:
Input: num = 100 Output: &amp;quot;202&amp;quot; Example 2:
Input: num = -7 Output: &amp;quot;-10&amp;quot; Constraints:
 -107 &amp;lt;= num &amp;lt;= 107   1 2 3 4 5 6 7 8 9  func convertToBase7(num int) string { if num &amp;lt; 0 { return &amp;#34;-&amp;#34; + convertToBase7(-num) } if num &amp;lt; 7 { return strconv.Itoa(num) } return convertToBase7(num/7) + strconv.</description>
    </item>
    
    <item>
      <title>1022 Sum of Root To Leaf Binary Numbers</title>
      <link>https://blog.siwei.dev/leetcode/1022-sum-of-root-to-leaf-binary-numbers/</link>
      <pubDate>Wed, 24 Mar 2021 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/1022-sum-of-root-to-leaf-binary-numbers/</guid>
      <description>You are given the root of a binary tree where each node has a value 0 or 1. Each root-to-leaf path represents a binary number starting with the most significant bit. For example, if the path is 0 -&amp;gt; 1 -&amp;gt; 1 -&amp;gt; 0 -&amp;gt; 1, then this could represent 01101 in binary, which is 13.
For all leaves in the tree, consider the numbers represented by the path from the root to that leaf.</description>
    </item>
    
    <item>
      <title>1114 Print in Order</title>
      <link>https://blog.siwei.dev/leetcode/1114-print-in-order/</link>
      <pubDate>Mon, 22 Mar 2021 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/1114-print-in-order/</guid>
      <description>Suppose we have a class:
public class Foo { public void first() { print(&amp;quot;first&amp;quot;); } public void second() { print(&amp;quot;second&amp;quot;); } public void third() { print(&amp;quot;third&amp;quot;); } } The same instance of Foo will be passed to three different threads. Thread A will call first(), thread B will call second(), and thread C will call third(). Design a mechanism and modify the program to ensure that second() is executed after first(), and third() is executed after second().</description>
    </item>
    
    <item>
      <title>1413 Minimum Value to Get Positive Step by Step Sum</title>
      <link>https://blog.siwei.dev/leetcode/1413-minimum-value-to-get-positive-step-by-step-sum/</link>
      <pubDate>Sun, 28 Mar 2021 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/1413-minimum-value-to-get-positive-step-by-step-sum/</guid>
      <description>Given an array of integers nums, you start with an initial positive value startValue.
In each iteration, you calculate the step by step sum of startValue plus elements in nums (from left to right).
Return the minimum positive value of startValue such that the step by step sum is never less than 1.
Example 1:
Input: nums = [-3,2,-3,4,2] Output: 5 Explanation: If you choose startValue = 4, in the third iteration your step by step sum is less than 1.</description>
    </item>
    
  </channel>
</rss>
