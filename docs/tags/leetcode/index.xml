<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>leetcode on Siwei&#39;s Blog</title>
    <link>https://blog.siwei.dev/tags/leetcode/</link>
    <description>Recent content in leetcode on Siwei&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 07 Aug 2022 00:00:00 -0400</lastBuildDate><atom:link href="https://blog.siwei.dev/tags/leetcode/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>1 Two Sum</title>
      <link>https://blog.siwei.dev/leetcode/1-two-sum/</link>
      <pubDate>Mon, 21 Sep 2020 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/1-two-sum/</guid>
      <description>Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.
You may assume that each input would have exactly one solution, and you may not use the same element twice.
You can return the answer in any order.
Example 1:
Input: nums = [2,7,11,15], target = 9 Output: [0,1] Output: Because nums[0] + nums[1] == 9, we return [0, 1].</description>
    </item>
    
    <item>
      <title>2 Add Two Numbers</title>
      <link>https://blog.siwei.dev/leetcode/2-add-two-numbers/</link>
      <pubDate>Mon, 21 Sep 2020 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/2-add-two-numbers/</guid>
      <description>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.
You may assume the two numbers do not contain any leading zero, except the number 0 itself.
Example 1:
(2 -&amp;gt; 4 -&amp;gt; 3) + (5 -&amp;gt; 6 -&amp;gt; 4) = (7 -&amp;gt; 0 -&amp;gt; 8) Input: l1 = [2,4,3], l2 = [5,6,4] Output: [7,0,8] Explanation: 342 + 465 = 807.</description>
    </item>
    
    <item>
      <title>3 Longest Substring Without Repeating Characters</title>
      <link>https://blog.siwei.dev/leetcode/3-longest-substring-without-repeating-characters/</link>
      <pubDate>Wed, 01 Jan 2020 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/3-longest-substring-without-repeating-characters/</guid>
      <description>Given a string s, find the length of the longest substring without repeating characters.
Example 1:
Input: s = &amp;quot;abcabcbb&amp;quot; Output: 3 Explanation: The answer is &amp;quot;abc&amp;quot;, with the length of 3. Example 2:
Input: s = &amp;quot;bbbbb&amp;quot; Output: 1 Explanation: The answer is &amp;quot;b&amp;quot;, with the length of 1. Example 3:
Input: s = &amp;quot;pwwkew&amp;quot; Output: 3 Explanation: The answer is &amp;quot;wke&amp;quot;, with the length of 3. Notice that the answer must be a substring, &amp;quot;pwke&amp;quot; is a subsequence and not a substring.</description>
    </item>
    
    <item>
      <title>4 Median of Two Sorted Arrays</title>
      <link>https://blog.siwei.dev/leetcode/4-median-of-two-sorted-arrays/</link>
      <pubDate>Sat, 24 Oct 2020 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/4-median-of-two-sorted-arrays/</guid>
      <description>Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.
Follow up: The overall run time complexity should be O(log (m+n)).
Example 1:
Input: nums1 = [1,3], nums2 = [2] Output: 2.00000 Explanation: merged array = [1,2,3] and median is 2. Example 2:
Input: nums1 = [1,2], nums2 = [3,4] Output: 2.50000 Explanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.</description>
    </item>
    
    <item>
      <title>5 Longest Palindromic Substring</title>
      <link>https://blog.siwei.dev/leetcode/5-longest-palindromic-substring/</link>
      <pubDate>Wed, 23 Sep 2020 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/5-longest-palindromic-substring/</guid>
      <description>Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.
Example1:
Input: &amp;quot;babad&amp;quot; Output: &amp;quot;bab&amp;quot; Note: &amp;quot;aba&amp;quot; is also a valid answer. Example2:
Input: &amp;quot;cbbd&amp;quot; Output: &amp;quot;bb&amp;quot;  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  func longestPalindrome(s string) string { if len(s) &amp;lt; 1 { return &amp;#34;&amp;#34; } start := 0 end := 0 for i := range s { len1 := expandAroundCenter(s, i, i) len2 := expandAroundCenter(s, i, i+1) lenMax := -1 if len1 &amp;gt; len2 { lenMax = len1 } else { lenMax = len2 } if lenMax &amp;gt; end-start+1 { start = i - (lenMax-1)/2 end = i + lenMax/2 } } return s[start : end+1] } func expandAroundCenter(s string, left int, right int) int { for left &amp;gt;= 0 &amp;amp;&amp;amp; right &amp;lt; len(s) &amp;amp;&amp;amp; s[left] == s[right] { left-- right++ } return right - left - 1 }    https://runtime.</description>
    </item>
    
    <item>
      <title>19 Remove Nth Node From End of List</title>
      <link>https://blog.siwei.dev/leetcode/19-remove-nth-node-from-end-of-list/</link>
      <pubDate>Sun, 19 Sep 2021 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/19-remove-nth-node-from-end-of-list/</guid>
      <description>Given the head of a linked list, remove the nth node from the end of the list and return its head.
Example 1:
1 -&amp;gt; 2 -&amp;gt; 3 -&amp;gt; (4) -&amp;gt; 5 1 -&amp;gt; 2 -&amp;gt; 3 --------&amp;gt; 5 Input: head = [1,2,3,4,5], n = 2 Output: [1,2,3,5] Example 2:
Input: head = [1], n = 1 Output: [] Example 3:
Input: head = [1,2], n = 1 Output: [1] Constraints:</description>
    </item>
    
    <item>
      <title>20 Valid Parentheses</title>
      <link>https://blog.siwei.dev/leetcode/20-valid-parentheses/</link>
      <pubDate>Fri, 25 Sep 2020 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/20-valid-parentheses/</guid>
      <description>Given a string s containing just the characters &#39;(&#39;, &#39;)&#39;, &#39;{&#39;, &#39;}&#39;, &#39;[&#39; and &#39;]&#39;, determine if the input string is valid.
An input string is valid if:
 Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order.  Example 1:
Input: s = &amp;quot;()&amp;quot; Output: true Example 2:
Input: s = &amp;quot;()[]{}&amp;quot; Output: true Example 3:
Input: s = &amp;quot;(]&amp;quot; Output: false Example 4:</description>
    </item>
    
    <item>
      <title>21 Merge Two Sorted Lists</title>
      <link>https://blog.siwei.dev/leetcode/21-merge-two-sorted-lists/</link>
      <pubDate>Sun, 18 Oct 2020 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/21-merge-two-sorted-lists/</guid>
      <description>Merge two sorted linked lists and return it as a new sorted list. The new list should be made by splicing together the nodes of the first two lists.
Example 1:
1 -&amp;gt; 2 -&amp;gt; 4 1 -&amp;gt; 3 -&amp;gt; 4 ------------ 1 -&amp;gt; 1 -&amp;gt; 2 -&amp;gt; 3 -&amp;gt; 4 -&amp;gt; 4 Input: l1 = [1,2,4], l2 = [1,3,4] Output: [1,1,2,3,4,4] Example 2:
Input: l1 = [], l2 = [] Output: [] Example 3:</description>
    </item>
    
    <item>
      <title>23 Merge k Sorted Lists</title>
      <link>https://blog.siwei.dev/leetcode/23-merge-k-sorted-lists/</link>
      <pubDate>Sat, 18 Sep 2021 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/23-merge-k-sorted-lists/</guid>
      <description>You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.
Merge all the linked-lists into one sorted linked-list and return it.
Example 1:
Input: lists = [[1,4,5],[1,3,4],[2,6]] Output: [1,1,2,3,4,4,5,6] Explanation: The linked-lists are: [ 1-&amp;gt;4-&amp;gt;5, 1-&amp;gt;3-&amp;gt;4, 2-&amp;gt;6 ] merging them into one sorted list: 1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4-&amp;gt;5-&amp;gt;6 Example 2:
Input: lists = [] Output: [] Example 2:
Input: lists = [[]] Output: [] Constraints:
 k == lists.</description>
    </item>
    
    <item>
      <title>35 Search Insert Position</title>
      <link>https://blog.siwei.dev/leetcode/35-search-insert-position/</link>
      <pubDate>Sat, 18 Sep 2021 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/35-search-insert-position/</guid>
      <description>Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.
You must write an algorithm with O(log n) runtime complexity.
Example 1:
Input: nums = [1,3,5,6], target = 5 Output: 2 Example 2:
Input: nums = [1,3,5,6], target = 2 Output: 1 Example 3:
Input: nums = [1,3,5,6], target = 7 Output: 4 Example 4:</description>
    </item>
    
    <item>
      <title>36 Valid Sudoku</title>
      <link>https://blog.siwei.dev/leetcode/36-valid-sudoku/</link>
      <pubDate>Thu, 30 Sep 2021 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/36-valid-sudoku/</guid>
      <description>Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:
Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.
Note:
 A Sudoku board (partially filled) could be valid but is not necessarily solvable.</description>
    </item>
    
    <item>
      <title>42 Trapping Rain Water</title>
      <link>https://blog.siwei.dev/leetcode/42-trapping-rain-water/</link>
      <pubDate>Sat, 26 Jun 2021 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/42-trapping-rain-water/</guid>
      <description>Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.
Example 1: Input: height = [0,1,0,2,1,0,1,3,2,1,2,1] Output: 6 Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Example 2:
Input: height = [4,2,0,3,2,5] Output: 9 Constraints:
 n == height.</description>
    </item>
    
    <item>
      <title>48 Rotate Image</title>
      <link>https://blog.siwei.dev/leetcode/48-rotate-image/</link>
      <pubDate>Fri, 19 Mar 2021 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/48-rotate-image/</guid>
      <description>You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).
You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.
Example 1:
1 2 3 7 4 1 4 5 6 =&amp;gt; 8 5 2 7 8 9 9 6 3 Input: matrix = [[1,2,3],[4,5,6],[7,8,9]] Output: [[7,4,1],[8,5,2],[9,6,3]] Example 2:</description>
    </item>
    
    <item>
      <title>50 Pow(x, n)</title>
      <link>https://blog.siwei.dev/leetcode/50-powx-n/</link>
      <pubDate>Thu, 11 Mar 2021 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/50-powx-n/</guid>
      <description>Implement pow(x, n), which calculates x raised to the power n (i.e. xn).
Example 1:
Input: x = 2.00000, n = 10 Output: 1024.00000 Example 2:
Input: x = 2.10000, n = 3 Output: 9.26100 Example 3:
Input: x = 2.00000, n = -2 Output: 0.25000 Explanation: 2^(-2) = 1/(2^2) = 1/4 = 0.25 Constraints:
 -100.0 &amp;lt; x &amp;lt; 100.0 -231 &amp;lt;= n &amp;lt;= 231-1 -104 &amp;lt;= xn &amp;lt;= 104   1 2 3 4 5 6 7 8 9 10 11 12 13  func myPow(x float64, n int) float64 { if n == 0 { return 1 } if n &amp;lt; 0 { return myPow(1/x, -n) } result := myPow(x*x, n/2) if n % 2 == 1 { result *= x } return result }     </description>
    </item>
    
    <item>
      <title>53 Maximum Subarray</title>
      <link>https://blog.siwei.dev/leetcode/53-maximum-subarray/</link>
      <pubDate>Sun, 19 Sep 2021 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/53-maximum-subarray/</guid>
      <description>Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.
A subarray is a contiguous part of an array.
Example 1:
Input: nums = [-2,1,-3,4,-1,2,1,-5,4] Output: 6 Explanation: [4,-1,2,1] has the largest sum = 6. Example 2:
Input: nums = [1] Output: 1 Example 3:
Input: nums = [5,4,-1,7,8] Output: 23 Constraints:
 1 &amp;lt;= nums.length &amp;lt;= 3 * 104 -105 &amp;lt;= nums[i] &amp;lt;= 105  Follow up: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.</description>
    </item>
    
    <item>
      <title>55 Jump Game</title>
      <link>https://blog.siwei.dev/leetcode/55-jump-game/</link>
      <pubDate>Thu, 18 Mar 2021 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/55-jump-game/</guid>
      <description>Given an array of non-negative integers nums, you are initially positioned at the first index of the array.
Each element in the array represents your maximum jump length at that position.
Determine if you are able to reach the last index.
Example 1:
Input: nums = [2,3,1,1,4] Output: true Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index. Example 2:
Input: nums = [3,2,1,0,4] Output: false Explanation: You will always arrive at index 3 no matter what.</description>
    </item>
    
    <item>
      <title>57 Insert Interval</title>
      <link>https://blog.siwei.dev/leetcode/57-insert-interval/</link>
      <pubDate>Fri, 19 Mar 2021 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/57-insert-interval/</guid>
      <description>Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).
You may assume that the intervals were initially sorted according to their start times.
Example 1:
Input: intervals = [[1,3],[6,9]], newInterval = [2,5] Output: [[1,5],[6,9]] Example 2:
Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8] Output: [[1,2],[3,10],[12,16]] Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10]. Example 3:
Input: intervals = [], newInterval = [5,7] Output: [[5,7]] Example 4:</description>
    </item>
    
    <item>
      <title>61 Rotate List</title>
      <link>https://blog.siwei.dev/leetcode/61-rotate-list/</link>
      <pubDate>Mon, 14 Jun 2021 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/61-rotate-list/</guid>
      <description>Given the head of a linked list, rotate the list to the right by k places.
Example 1:
 1 -&amp;gt; 2 -&amp;gt; 3 -&amp;gt; 4 -&amp;gt; 5 rotate 1: 5 -&amp;gt; 1 -&amp;gt; 2 -&amp;gt; 3 -&amp;gt; 4 rotate 2: 4 -&amp;gt; 5 -&amp;gt; 1 -&amp;gt; 2 -&amp;gt; 3 Input: head = [1,2,3,4,5], k = 2 Output: [4,5,1,2,3] Example 2:
 0 -&amp;gt; 1 -&amp;gt; 2 rotate 1: 2 -&amp;gt; 0 -&amp;gt; 1 rotate 2: 1 -&amp;gt; 2 -&amp;gt; 0 rotate 3: 0 -&amp;gt; 1 -&amp;gt; 2 rotate 4: 2 -&amp;gt; 0 -&amp;gt; 1 Input: head = [0,1,2], k = 4 Output: [2,0,1] Constraints:</description>
    </item>
    
    <item>
      <title>70 Climbing Stairs</title>
      <link>https://blog.siwei.dev/leetcode/70-climbing-stairs/</link>
      <pubDate>Tue, 21 Sep 2021 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/70-climbing-stairs/</guid>
      <description>You are climbing a staircase. It takes n steps to reach the top.
Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?
Example 1:
Input: n = 2 Output: 2 Explanation: There are two ways to climb to the top. 1. 1 step + 1 step 2. 2 steps Example 2:
Input: n = 3 Output: 3 Explanation: There are three ways to climb to the top.</description>
    </item>
    
    <item>
      <title>74 Search a 2D Matrix</title>
      <link>https://blog.siwei.dev/leetcode/74-search-a-2d-matrix/</link>
      <pubDate>Thu, 30 Sep 2021 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/74-search-a-2d-matrix/</guid>
      <description>Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:
 Integers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row.  Example 1:
 1 (3) 5 7 10 11 16 20 23 30 34 60 Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3 Output: true Example 2:</description>
    </item>
    
    <item>
      <title>79 Word Search</title>
      <link>https://blog.siwei.dev/leetcode/79-word-search/</link>
      <pubDate>Thu, 30 Sep 2021 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/79-word-search/</guid>
      <description>Given an m x n grid of characters board and a string word, return true if word exists in the grid.
The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.
Example 1:
(A) (B) (C) E S F (C) S A (D) (E) E Input: board = [[&amp;quot;A&amp;quot;,&amp;quot;B&amp;quot;,&amp;quot;C&amp;quot;,&amp;quot;E&amp;quot;],[&amp;quot;S&amp;quot;,&amp;quot;F&amp;quot;,&amp;quot;C&amp;quot;,&amp;quot;S&amp;quot;],[&amp;quot;A&amp;quot;,&amp;quot;D&amp;quot;,&amp;quot;E&amp;quot;,&amp;quot;E&amp;quot;]], word = &amp;quot;ABCCED&amp;quot; Output: true Example 2:</description>
    </item>
    
    <item>
      <title>83 Remove Duplicates from Sorted List</title>
      <link>https://blog.siwei.dev/leetcode/83-remove-duplicates-from-sorted-list/</link>
      <pubDate>Sat, 02 Oct 2021 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/83-remove-duplicates-from-sorted-list/</guid>
      <description>Given the head of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well.
Example 1:
1 -&amp;gt; 1 -&amp;gt; 2 | v 1 -&amp;gt; 2 Input: head = [1,1,2] Output: [1,2] Example 2:
1 -&amp;gt; 1 -&amp;gt; 2 -&amp;gt; 3 -&amp;gt; 3 | v 1 -&amp;gt; 2 -&amp;gt; 3 Input: head = [1,1,2,3,3] Output: [1,2,3] Constraints:
 The number of nodes in the list is in the range [0, 300].</description>
    </item>
    
    <item>
      <title>88 Merge Sorted Array</title>
      <link>https://blog.siwei.dev/leetcode/88-merge-sorted-array/</link>
      <pubDate>Tue, 21 Sep 2021 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/88-merge-sorted-array/</guid>
      <description>You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.
Merge nums1 and nums2 into a single array sorted in non-decreasing order.
The final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored.</description>
    </item>
    
    <item>
      <title>94 Binary Tree Inorder Traversal</title>
      <link>https://blog.siwei.dev/leetcode/94-binary-tree-inorder-traversal/</link>
      <pubDate>Sat, 02 Oct 2021 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/94-binary-tree-inorder-traversal/</guid>
      <description>Given the root of a binary tree, return the inorder traversal of its nodes&#39; values.
Example 1:
 1 \ 2 / 3 Input: root = [1,null,2,3] Output: [1,3,2] Example 2:
Input: root = [] Output: [] Example 3:
Input: root = [1] Output: [1] Example 4:
 1 / 2 Input: root = [1,2] Output: [2,1] Example 5:
 1 \ 2 Input: root = [1,null,2] Output: [1,2] Constraints:</description>
    </item>
    
    <item>
      <title>100 Same Tree</title>
      <link>https://blog.siwei.dev/leetcode/100-same-tree/</link>
      <pubDate>Wed, 09 Jun 2021 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/100-same-tree/</guid>
      <description>Given the roots of two binary trees p and q, write a function to check if they are the same or not.
Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.
Example 1:
 1 1 / \ / \ 2 3 2 3 Input: p = [1,2,3], q = [1,2,3] Output: true Example 2:
 1 1 / \ 2 2 Input: p = [1,2], q = [1,null,2] Output: false Example 3:</description>
    </item>
    
    <item>
      <title>101 Symmetric Tree</title>
      <link>https://blog.siwei.dev/leetcode/101-symmetric-tree/</link>
      <pubDate>Sat, 20 Mar 2021 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/101-symmetric-tree/</guid>
      <description>Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).
Example 1:
 1 / \ 2 2 / \ / \ 3 4 4 3 Input: root = [1,2,2,3,4,4,3] Output: true Example 2:
 1 / \ 2 2 \ \ 3 3 Input: root = [1,2,2,null,3,null,3] Output: false Constraints:
 The number of nodes in the tree is in the range [1, 1000].</description>
    </item>
    
    <item>
      <title>102 Binary Tree Level Order Traversal</title>
      <link>https://blog.siwei.dev/leetcode/102-binary-tree-level-order-traversal/</link>
      <pubDate>Sat, 02 Oct 2021 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/102-binary-tree-level-order-traversal/</guid>
      <description>Given the root of a binary tree, return the level order traversal of its nodes&#39; values. (i.e., from left to right, level by level).
Example 1:
 3 / \ 9 20 / \ 15 7 Input: root = [3,9,20,null,null,15,7] Output: [[3],[9,20],[15,7]] Example 2:
Input: root = [1] Output: [[1]] Example 3:
Input: root = [] Output: [] Constraints:
 The number of nodes in the tree is in the range [0, 2000].</description>
    </item>
    
    <item>
      <title>103 Binary Tree Zigzag Level Order Traversal</title>
      <link>https://blog.siwei.dev/leetcode/103-binary-tree-zigzag-level-order-traversal/</link>
      <pubDate>Sun, 21 Mar 2021 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/103-binary-tree-zigzag-level-order-traversal/</guid>
      <description>Given the root of a binary tree, return the zigzag level order traversal of its nodes&#39; values. (i.e., from left to right, then right to left for the next level and alternate between).
Example 1:
 3 / \ 9 20 / \ 15 7 Input: root = [3,9,20,null,null,15,7] Output: [[3],[20,9],[15,7]] Example 2:
Input: root = [1] Output: [[1]] Example 3:
Input: root = [] Output: [] Constraints:
 The number of nodes in the tree is in the range [0, 2000].</description>
    </item>
    
    <item>
      <title>104 Maximum Depth of Binary Tree</title>
      <link>https://blog.siwei.dev/leetcode/104-maximum-depth-of-binary-tree/</link>
      <pubDate>Sat, 02 Oct 2021 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/104-maximum-depth-of-binary-tree/</guid>
      <description>Given the root of a binary tree, return its maximum depth.
A binary tree&amp;rsquo;s maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.
Example 1:
 3 / \ 9 20 / \ 15 7 Input: root = [3,9,20,null,null,15,7] Output: 3 Example 2:
Input: root = [1,null,2] Output: 2 Example 3:
Input: root = [] Output: 0 Example 4:</description>
    </item>
    
    <item>
      <title>109 Convert Sorted List to Binary Search Tree</title>
      <link>https://blog.siwei.dev/leetcode/109-convert-sorted-list-to-binary-search-tree/</link>
      <pubDate>Sun, 21 Mar 2021 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/109-convert-sorted-list-to-binary-search-tree/</guid>
      <description>Given the head of a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.
For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.
Example 1:
-10 -&amp;gt; -3 -&amp;gt; 0 -&amp;gt; 5 -&amp;gt; 9 0 0 / \ / \ -10 5 or -3 9 \ \ / / -3 9 -10 5 Input: head = [-10,-3,0,5,9] Output: [0,-3,9,-10,null,5] Explanation: One possible answer is [0,-3,9,-10,null,5], which represents the shown height balanced BST.</description>
    </item>
    
    <item>
      <title>112 Path Sum</title>
      <link>https://blog.siwei.dev/leetcode/112-path-sum/</link>
      <pubDate>Sat, 02 Oct 2021 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/112-path-sum/</guid>
      <description>Given the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum.
A leaf is a node with no children.
Example 1:
 5 / \ 4 8 / / \ 11 13 4 / \ \ 7 2 1 Input: root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22 Output: true Example 2:</description>
    </item>
    
    <item>
      <title>113 Path Sum II</title>
      <link>https://blog.siwei.dev/leetcode/113-path-sum-ii/</link>
      <pubDate>Thu, 25 Mar 2021 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/113-path-sum-ii/</guid>
      <description>Given the root of a binary tree and an integer targetSum, return all root-to-leaf paths where each path&amp;rsquo;s sum equals targetSum.
A leaf is a node with no children.
Example 1:
 5 / \ 4 8 / / \ 11 13 4 / \ / \ 7 2 5 1 Input: root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22 Output: [[5,4,11,2],[5,8,4,5]] Example 2:
 1 / \ 2 3 Input: root = [1,2,3], targetSum = 5 Output: [] Example 3:</description>
    </item>
    
    <item>
      <title>118 Pascal&#39;s Triangle</title>
      <link>https://blog.siwei.dev/leetcode/118-pascals-triangle/</link>
      <pubDate>Thu, 30 Sep 2021 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/118-pascals-triangle/</guid>
      <description>Given an integer numRows, return the first numRows of Pascal&amp;rsquo;s triangle.
In Pascal&amp;rsquo;s triangle, each number is the sum of the two numbers directly above it as shown:
 1 1 1 1 2 1 1 3 3 1 1 4 6 4 1 Example 1:
Input: numRows = 5 Output: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]] Example 2:
Input: numRows = 1 Output: [[1]] Constraints:
 1 &amp;lt;= numRows &amp;lt;= 30   1 2 3 4 5 6 7 8 9 10 11 12 13  class Solution: def __init__(self): self.</description>
    </item>
    
    <item>
      <title>121 Best Time to Buy and Sell Stock</title>
      <link>https://blog.siwei.dev/leetcode/121-best-time-to-buy-and-sell-stock/</link>
      <pubDate>Thu, 23 Sep 2021 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/121-best-time-to-buy-and-sell-stock/</guid>
      <description>You are given an array prices where prices[i] is the price of a given stock on the ith day.
You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.
Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.
Example 1:
Input: prices = [7,1,5,3,6,4] Output: 5 Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.</description>
    </item>
    
    <item>
      <title>122 Best Time to Buy and Sell Stock II</title>
      <link>https://blog.siwei.dev/leetcode/122-best-time-to-buy-and-sell-stock-ii/</link>
      <pubDate>Sun, 25 Oct 2020 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/122-best-time-to-buy-and-sell-stock-ii/</guid>
      <description>Say you have an array prices for which the ith element is the price of a given stock on day i.
Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).
Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).</description>
    </item>
    
    <item>
      <title>123 Best Time to Buy and Sell Stock III</title>
      <link>https://blog.siwei.dev/leetcode/123-best-time-to-buy-and-sell-stock-iii/</link>
      <pubDate>Fri, 26 Mar 2021 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/123-best-time-to-buy-and-sell-stock-iii/</guid>
      <description>You are given an array prices where prices[i] is the price of a given stock on the ith day.
Find the maximum profit you can achieve. You may complete at most two transactions.
Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).
Example 1:
Input: prices = [3,3,5,0,0,3,1,4] Output: 6 Explanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.</description>
    </item>
    
    <item>
      <title>136 Single Number</title>
      <link>https://blog.siwei.dev/leetcode/136-single-number/</link>
      <pubDate>Sat, 26 Sep 2020 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/136-single-number/</guid>
      <description>Given a non-empty array of integers, every element appears twice except for one. Find that single one.
Note:
Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?
Example 1:
Input: [2,2,1] Output: 1 Example 2:
Input: [4,1,2,1,2] Output: 4  1 2 3 4 5 6 7 8 9 10 11 12 13 14  func singleNumber(nums []int) int { set := make(map[int]bool) for _, num := range nums { if _, ok := set[num]; ok { delete(set, num) } else { set[num] = true } } for num, _ := range set { return num } return -1 }    https://runtime.</description>
    </item>
    
    <item>
      <title>141 Linked List Cycle</title>
      <link>https://blog.siwei.dev/leetcode/141-linked-list-cycle/</link>
      <pubDate>Fri, 01 Oct 2021 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/141-linked-list-cycle/</guid>
      <description>Given head, the head of a linked list, determine if the linked list has a cycle in it.
There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail&amp;rsquo;s next pointer is connected to. Note that pos is not passed as a parameter.</description>
    </item>
    
    <item>
      <title>144 Binary Tree Preorder Traversal</title>
      <link>https://blog.siwei.dev/leetcode/144-binary-tree-preorder-traversal/</link>
      <pubDate>Sat, 02 Oct 2021 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/144-binary-tree-preorder-traversal/</guid>
      <description>Given the root of a binary tree, return the preorder traversal of its nodes&#39; values.
Example 1:
 1 \ 2 / 3 Input: root = [1,null,2,3] Output: [1,2,3] Example 2:
Input: root = [] Output: [] Example 3:
Input: root = [1] Output: [1] Example 4:
 1 / 2 Input: root = [1,2] Output: [1,2] Example 5:
 1 \ 2 Input: root = [1,null,2] Output: [1,2] Constraints:</description>
    </item>
    
    <item>
      <title>145 Binary Tree Postorder Traversal</title>
      <link>https://blog.siwei.dev/leetcode/145-binary-tree-postorder-traversal/</link>
      <pubDate>Sat, 02 Oct 2021 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/145-binary-tree-postorder-traversal/</guid>
      <description>Given the root of a binary tree, return the postorder traversal of its nodes&#39; values.
Example 1:
 1 \ 2 / 3 Input: root = [1,null,2,3] Output: [3,2,1] Example 2:
Input: root = [] Output: [] Example 3:
Input: root = [1] Output: [1] Example 4:
 1 / 2 Input: root = [1,2] Output: [2,1] Example 5:
 1 \ 2 Input: root = [1,null,2] Output: [2,1] Constraints:</description>
    </item>
    
    <item>
      <title>146 LRU Cache</title>
      <link>https://blog.siwei.dev/leetcode/146-lru-cache/</link>
      <pubDate>Thu, 30 Sep 2021 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/146-lru-cache/</guid>
      <description>Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.
Implement the LRUCache class:
 LRUCache(int capacity) Initialize the LRU cache with positive size capacity. int get(int key) Return the value of the key if the key exists, otherwise return -1. void put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.</description>
    </item>
    
    <item>
      <title>167 Two Sum II - Input array is sorted</title>
      <link>https://blog.siwei.dev/leetcode/167-two-sum-ii-input-array-is-sorted/</link>
      <pubDate>Sat, 18 Sep 2021 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/167-two-sum-ii-input-array-is-sorted/</guid>
      <description>Given an array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number.
Return the indices of the two numbers (1-indexed) as an integer array answer of size 2, where 1 &amp;lt;= answer[0] &amp;lt; answer[1] &amp;lt;= numbers.length.
The tests are generated such that there is exactly one solution. You may not use the same element twice.
Example 1:</description>
    </item>
    
    <item>
      <title>189 Rotate Array</title>
      <link>https://blog.siwei.dev/leetcode/189-rotate-array/</link>
      <pubDate>Sat, 18 Sep 2021 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/189-rotate-array/</guid>
      <description>Given an array, rotate the array to the right by k steps, where k is non-negative.
Example 1:
Input: nums = [1,2,3,4,5,6,7], k = 3 Output: [5,6,7,1,2,3,4] Explanation: rotate 1 steps to the right: [7,1,2,3,4,5,6] rotate 2 steps to the right: [6,7,1,2,3,4,5] rotate 3 steps to the right: [5,6,7,1,2,3,4] Example 2:
Input: nums = [-1,-100,3,99], k = 2 Output: [3,99,-1,-100] Explanation: rotate 1 steps to the right: [99,-1,-100,3] rotate 2 steps to the right: [3,99,-1,-100] Constraints:</description>
    </item>
    
    <item>
      <title>200 Number of Islands</title>
      <link>https://blog.siwei.dev/leetcode/200-number-of-islands/</link>
      <pubDate>Thu, 10 Dec 2020 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/200-number-of-islands/</guid>
      <description>Given an m x n 2d grid map of &#39;1&#39;s (land) and &#39;0&#39;s (water), return the number of islands.
An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.
Example 1:
Input: grid = [ [&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;], [&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;], [&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;], [&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;] ] Output: 1 Example 2:
Input: grid = [ [&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;], [&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;], [&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;], [&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;] ] Output: 3 Constraints:</description>
    </item>
    
    <item>
      <title>203 Remove Linked List Elements</title>
      <link>https://blog.siwei.dev/leetcode/203-remove-linked-list-elements/</link>
      <pubDate>Fri, 01 Oct 2021 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/203-remove-linked-list-elements/</guid>
      <description>Given the head of a linked list and an integer val, remove all the nodes of the linked list that has Node.val == val, and return the new head.
Example 1:
1 -&amp;gt; 2 -&amp;gt; (6) -&amp;gt; 3 -&amp;gt; 4 -&amp;gt; 5 -&amp;gt; (6) | v 1 -&amp;gt; 2 -&amp;gt; 3 -&amp;gt; 4 -&amp;gt; 5 Input: head = [1,2,6,3,4,5,6], val = 6 Output: [1,2,3,4,5] Example 2:
Input: head = [], val = 1 Output: [] Example 3:</description>
    </item>
    
    <item>
      <title>206 Reverse Linked List</title>
      <link>https://blog.siwei.dev/leetcode/206-reverse-linked-list/</link>
      <pubDate>Sat, 02 Oct 2021 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/206-reverse-linked-list/</guid>
      <description>Given the head of a singly linked list, reverse the list, and return the reversed list.
Example 1:
1 -&amp;gt; 2 -&amp;gt; 3 -&amp;gt; 4 -&amp;gt; 5 | v 5 -&amp;gt; 4 -&amp;gt; 3 -&amp;gt; 2 -&amp;gt; 1 Input: head = [1,2,3,4,5] Output: [5,4,3,2,1] Example 2:
1 -&amp;gt; 2 2 -&amp;gt; 1 Input: head = [1,2] Output: [2,1] Example 3:
Input: head = [] Output: [] Constraints:
 The number of nodes in the list is the range [0, 5000].</description>
    </item>
    
    <item>
      <title>217 Contains Duplicate</title>
      <link>https://blog.siwei.dev/leetcode/217-contains-duplicate/</link>
      <pubDate>Sun, 19 Sep 2021 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/217-contains-duplicate/</guid>
      <description>Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.
Example 1:
Input: nums = [1,2,3,1] Output: true Example 2:
Input: nums = [1,2,3,4] Output: false Example 3:
Input: nums = [1,1,1,3,3,4,3,2,4,2] Output: true Constraints:
 1 &amp;lt;= nums.length &amp;lt;= 105 -109 &amp;lt;= nums[i] &amp;lt;= 109   1 2 3  class Solution: def containsDuplicate(self, nums: List[int]) -&amp;gt; bool: return len(set(nums)) !</description>
    </item>
    
    <item>
      <title>226 Invert Binary Tree</title>
      <link>https://blog.siwei.dev/leetcode/226-invert-binary-tree/</link>
      <pubDate>Sat, 02 Oct 2021 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/226-invert-binary-tree/</guid>
      <description>Given the root of a binary tree, invert the tree, and return its root.
Example 1:
 4 4 / \ / \ 2 7 =&amp;gt; 7 2 / \ / \ / \ / \ 1 3 6 9 1 3 6 9 Input: root = [4,2,7,1,3,6,9] Output: [4,7,2,9,6,3,1] Example 2:
 2 2 / \ =&amp;gt; / \ 1 3 3 1 Input: root = [2,1,3] Output: [2,3,1] Example 3:</description>
    </item>
    
    <item>
      <title>231 Power of Two</title>
      <link>https://blog.siwei.dev/leetcode/231-power-of-two/</link>
      <pubDate>Tue, 20 Oct 2020 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/231-power-of-two/</guid>
      <description>Given an integer n, write a function to determine if it is a power of two.
Example 1:
Input: n = 1 Output: true Explanation: 20 = 1 Example 2:
Input: n = 16 Output: true Explanation: 24 = 16 Example 3:
Input: n = 3 Output: false Example 4:
Input: n = 4 Output: true Example 5:
Input: n = 5 Output: false Constraints:
 -231 &amp;lt;= n &amp;lt;= 231 - 1   1 2 3 4 5 6 7  func isPowerOfTwo(n int) bool { i := 1 for i &amp;lt; n { i *= 2 } return i == n }    https://runtime.</description>
    </item>
    
    <item>
      <title>232 Implement Queue using Stacks</title>
      <link>https://blog.siwei.dev/leetcode/232-implement-queue-using-stacks/</link>
      <pubDate>Sat, 02 Oct 2021 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/232-implement-queue-using-stacks/</guid>
      <description>Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (push, peek, pop, and empty).
Implement the MyQueue class:
 void push(int x) Pushes element x to the back of the queue. int pop() Removes the element from the front of the queue and returns it. int peek() Returns the element at the front of the queue.</description>
    </item>
    
    <item>
      <title>235 Lowest Common Ancestor of a Binary Search Tree</title>
      <link>https://blog.siwei.dev/leetcode/235-lowest-common-ancestor-of-a-binary-search-tree/</link>
      <pubDate>Sat, 02 Oct 2021 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/235-lowest-common-ancestor-of-a-binary-search-tree/</guid>
      <description>Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.
According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”
Example 1:
 6 / \ 2 8 / \ / \ 0 4 7 9 / \ 3 5 Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8 Output: 6 Explanation: The LCA of nodes 2 and 8 is 6.</description>
    </item>
    
    <item>
      <title>242 Valid Anagram</title>
      <link>https://blog.siwei.dev/leetcode/242-valid-anagram/</link>
      <pubDate>Thu, 10 Dec 2020 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/242-valid-anagram/</guid>
      <description>Given two strings s and t , write a function to determine if t is an anagram of s.
Example 1:
Input: s = &amp;quot;anagram&amp;quot;, t = &amp;quot;nagaram&amp;quot; Output: true Example 2:
Input: s = &amp;quot;rat&amp;quot;, t = &amp;quot;car&amp;quot; Output: false Constraints:
 1 &amp;lt;= s.length, t.length &amp;lt;= 5 * 104 s and t consist of lowercase English letters.  Follow up: What if the inputs contain unicode characters? How would you adapt your solution to such case?</description>
    </item>
    
    <item>
      <title>253 Meeting Rooms II</title>
      <link>https://blog.siwei.dev/leetcode/253-meeting-rooms-ii/</link>
      <pubDate>Thu, 30 Sep 2021 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/253-meeting-rooms-ii/</guid>
      <description>Given an array of meeting time intervals intervals where intervals[i] = [starti, endi], return the minimum number of conference rooms required.
Example 1:
Input: intervals = [[0,30],[5,10],[15,20]] Output: 2 Example 2:
Input: intervals = [[7,10],[2,4]] Output: 1 Constraints:
 1 &amp;lt;= intervals.length &amp;lt;= 104 0 &amp;lt;= starti &amp;lt; endi &amp;lt;= 106   1 2 3 4 5 6 7 8 9 10 11 12 13  class Solution: def minMeetingRooms(self, intervals: List[List[int]]) -&amp;gt; int: free_rooms = [] intervals.</description>
    </item>
    
    <item>
      <title>278  First Bad Version</title>
      <link>https://blog.siwei.dev/leetcode/278-first-bad-version/</link>
      <pubDate>Fri, 17 Sep 2021 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/278-first-bad-version/</guid>
      <description>You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.
Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.</description>
    </item>
    
    <item>
      <title>283 Move Zeroes</title>
      <link>https://blog.siwei.dev/leetcode/283-move-zeroes/</link>
      <pubDate>Sat, 18 Sep 2021 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/283-move-zeroes/</guid>
      <description>Given an integer array nums, move all 0&amp;rsquo;s to the end of it while maintaining the relative order of the non-zero elements.
Note that you must do this in-place without making a copy of the array.
Example 1:
Input: nums = [0,1,0,3,12] Output: [1,3,12,0,0] Example 2:
Input: nums = [0] Output: [0] Constraints:
 1 &amp;lt;= nums.length &amp;lt;= 104 -231 &amp;lt;= nums[i] &amp;lt;= 231 - 1  Follow up: Could you minimize the total number of operations done?</description>
    </item>
    
    <item>
      <title>295 Find Median from Data Stream</title>
      <link>https://blog.siwei.dev/leetcode/295-find-median-from-data-stream/</link>
      <pubDate>Wed, 13 Oct 2021 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/295-find-median-from-data-stream/</guid>
      <description>The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value and the median is the mean of the two middle values.
  For example, for arr = [2,3,4], the median is 3.
  For example, for arr = [2,3], the median is (2 + 3) / 2 = 2.5. Implement the MedianFinder class:
  MedianFinder() initializes the MedianFinder object.</description>
    </item>
    
    <item>
      <title>344 Reverse String</title>
      <link>https://blog.siwei.dev/leetcode/344-reverse-string/</link>
      <pubDate>Tue, 20 Oct 2020 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/344-reverse-string/</guid>
      <description>Write a function that reverses a string. The input string is given as an array of characters char[].
Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.
You may assume all the characters consist of printable ascii characters.
Example 1:
Input: [&amp;quot;h&amp;quot;,&amp;quot;e&amp;quot;,&amp;quot;l&amp;quot;,&amp;quot;l&amp;quot;,&amp;quot;o&amp;quot;] Output: [&amp;quot;o&amp;quot;,&amp;quot;l&amp;quot;,&amp;quot;l&amp;quot;,&amp;quot;e&amp;quot;,&amp;quot;h&amp;quot;] Example 2:
Input: [&amp;quot;H&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;n&amp;quot;,&amp;quot;n&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;h&amp;quot;] Output: [&amp;quot;h&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;n&amp;quot;,&amp;quot;n&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;H&amp;quot;]  1 2 3 4 5 6 7 8 9 10 11  func reverseString(s []byte]) { i , j := 0, len(s) - 1 for i &amp;lt; j { temp := s[i] s[i] = s[j] i++ s[j] = temp j-- } fmt.</description>
    </item>
    
    <item>
      <title>347 Top K Frequent Elements</title>
      <link>https://blog.siwei.dev/leetcode/347-top-k-frequent-elements/</link>
      <pubDate>Wed, 17 Mar 2021 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/347-top-k-frequent-elements/</guid>
      <description>Given a non-empty array of integers, return the k most frequent elements.
Example 1:
Input: nums = [1,1,1,2,2,3], k = 2 Output: [1,2] Example 2:
Input: nums = [1], k = 1 Output: [1] Note:
 You may assume k is always valid, 1 ≤ k ≤ number of unique elements. Your algorithm&amp;rsquo;s time complexity must be better than O(n log n), where n is the array&amp;rsquo;s size. It&amp;rsquo;s guaranteed that the answer is unique, in other words the set of the top k frequent elements is unique.</description>
    </item>
    
    <item>
      <title>350 Intersection of Two Arrays II</title>
      <link>https://blog.siwei.dev/leetcode/350-intersection-of-two-arrays-ii/</link>
      <pubDate>Thu, 30 Sep 2021 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/350-intersection-of-two-arrays-ii/</guid>
      <description>Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays and you may return the result in any order.
Example 1:
Input: nums1 = [1,2,2,1], nums2 = [2,2] Output: [2,2] Example 2:
Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4] Output: [4,9] Explanation: [9,4] is also accepted. Constraints:
 1 &amp;lt;= nums1.length, nums2.</description>
    </item>
    
    <item>
      <title>357 Count Numbers with Unique Digits</title>
      <link>https://blog.siwei.dev/leetcode/357-count-numbers-with-unique-digits/</link>
      <pubDate>Sun, 07 Aug 2022 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/357-count-numbers-with-unique-digits/</guid>
      <description>Given an integer n, return the count of all numbers with unique digits, x, where 0 &amp;lt;= x &amp;lt; 10n.
Example 1:
Input: n = 2 Output: 91 Explanation: The answer should be the total numbers in the range of 0 ≤ x &amp;lt; 100, excluding 11,22,33,44,55,66,77,88,99 Example 2:
Input: n = 0 Output: 1 Constraints:
 0 &amp;lt;= n &amp;lt;= 8   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  class Solution: &amp;#39;&amp;#39;&amp;#39; &amp;lt;x-digit num: y numbers with unique digits&amp;gt; 0: 1 1: 9 2: 9*9 3: 9*9*8 4: 9*9*8*7 &amp;#39;&amp;#39;&amp;#39; def countNumbersWithUniqueDigits(self, n: int) -&amp;gt; int: res = 1 acc = 9 cur = 9 i = 1 while i &amp;lt;= n: res += acc acc *= cur cur -= 1 i += 1 return res     </description>
    </item>
    
    <item>
      <title>383 Ransom Note</title>
      <link>https://blog.siwei.dev/leetcode/383-ransom-note/</link>
      <pubDate>Fri, 01 Oct 2021 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/383-ransom-note/</guid>
      <description>Given two stings ransomNote and magazine, return true if ransomNote can be constructed from magazine and false otherwise.
Each letter in magazine can only be used once in ransomNote.
Example 1:
Input: ransomNote = &amp;quot;a&amp;quot;, magazine = &amp;quot;b&amp;quot; Output: false Example 2:
Input: ransomNote = &amp;quot;aa&amp;quot;, magazine = &amp;quot;ab&amp;quot; Output: false Example 3:
Input: ransomNote = &amp;quot;aa&amp;quot;, magazine = &amp;quot;aab&amp;quot; Output: true Constraints:
 1 &amp;lt;= ransomNote.length, magazine.length &amp;lt;= 105 ransomNote and magazine consist of lowercase English letters.</description>
    </item>
    
    <item>
      <title>387 First Unique Character in a String</title>
      <link>https://blog.siwei.dev/leetcode/387-first-unique-character-in-a-string/</link>
      <pubDate>Sun, 20 Dec 2020 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/387-first-unique-character-in-a-string/</guid>
      <description>Given a string s, find the first non-repeating character in it and return its index. If it does not exist, return -1.
Example 1:
Input: s = &amp;quot;leetcode&amp;quot; Output: 0 Example 2:
Input: s = &amp;quot;loveleetcode&amp;quot; Output: 2 Example 3:
Input: s = &amp;quot;aabb&amp;quot; Output: -1 Constraints:
 1 &amp;lt;= s.length &amp;lt;= 105 s consists of only lowercase English letters.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  func firstUniqChar(s string) int { m := make(map[rune]int) for _, c := range s { _, has := m[c] if has { m[c]++ } else { m[c] = 1 } } for i, c := range s { if m[c] == 1 { return i } } return -1 }    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class Solution: def firstUniqChar(self, s: str) -&amp;gt; int: count = collections.</description>
    </item>
    
    <item>
      <title>400 Nth Digit</title>
      <link>https://blog.siwei.dev/leetcode/400-nth-digit/</link>
      <pubDate>Wed, 28 Oct 2020 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/400-nth-digit/</guid>
      <description>Find the nth digit of the infinite integer sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, &amp;hellip;
Note: n is positive and will fit within the range of a 32-bit signed integer (n &amp;lt; 231).
Example 1:
Input: 3 Output: 3 Example 2:
Input: 11 Output: 0 Explanation: The 11th digit of the sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... is a 0, which is part of the number 10.</description>
    </item>
    
    <item>
      <title>405 Convert a Number to Hexadecimal</title>
      <link>https://blog.siwei.dev/leetcode/405-convert-a-number-to-hexadecimal/</link>
      <pubDate>Tue, 30 Mar 2021 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/405-convert-a-number-to-hexadecimal/</guid>
      <description>Given an integer, write an algorithm to convert it to hexadecimal. For negative integer, two’s complement method is used.
Note:
All letters in hexadecimal (a-f) must be in lowercase. The hexadecimal string must not contain extra leading 0s. If the number is zero, it is represented by a single zero character &#39;0&#39;; otherwise, the first character in the hexadecimal string will not be the zero character. The given number is guaranteed to fit within the range of a 32-bit signed integer.</description>
    </item>
    
    <item>
      <title>412 Fizz Buzz</title>
      <link>https://blog.siwei.dev/leetcode/412-fizz-buzz/</link>
      <pubDate>Thu, 24 Sep 2020 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/412-fizz-buzz/</guid>
      <description>Write a program that outputs the string representation of numbers from 1 to n.
But for multiples of three it should output “Fizz” instead of the number and for the multiples of five output “Buzz”. For numbers which are multiples of both three and five output “FizzBuzz”.
Example:
n = 15, Return: [ &amp;quot;1&amp;quot;, &amp;quot;2&amp;quot;, &amp;quot;Fizz&amp;quot;, &amp;quot;4&amp;quot;, &amp;quot;Buzz&amp;quot;, &amp;quot;Fizz&amp;quot;, &amp;quot;7&amp;quot;, &amp;quot;8&amp;quot;, &amp;quot;Fizz&amp;quot;, &amp;quot;Buzz&amp;quot;, &amp;quot;11&amp;quot;, &amp;quot;Fizz&amp;quot;, &amp;quot;13&amp;quot;, &amp;quot;14&amp;quot;, &amp;quot;FizzBuzz&amp;quot; ]  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  func fizzBuzz(n int) []string { var result []string for i := 1; i &amp;lt;= n; i++ { if i%3 == 0 &amp;amp;&amp;amp; i%5 == 0 { result = append(result, &amp;#34;FizzBuzz&amp;#34;) } else if i%3 == 0 { result = append(result, &amp;#34;Fizz&amp;#34;) } else if i%5 == 0 { result = append(result, &amp;#34;Buzz&amp;#34;) } else { result = append(result, strconv.</description>
    </item>
    
    <item>
      <title>476 Number Complement</title>
      <link>https://blog.siwei.dev/leetcode/476-number-complement/</link>
      <pubDate>Thu, 10 Dec 2020 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/476-number-complement/</guid>
      <description>Given a positive integer num, output its complement number. The complement strategy is to flip the bits of its binary representation.
Example 1:
Input: num = 5 Output: 2 Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2. Example 2:
Input: num = 1 Output: 0 Explanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0.</description>
    </item>
    
    <item>
      <title>504 Base 7</title>
      <link>https://blog.siwei.dev/leetcode/504-base-7/</link>
      <pubDate>Tue, 08 Jun 2021 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/504-base-7/</guid>
      <description>Given an integer num, return a string of its base 7 representation.
Example 1:
Input: num = 100 Output: &amp;quot;202&amp;quot; Example 2:
Input: num = -7 Output: &amp;quot;-10&amp;quot; Constraints:
 -107 &amp;lt;= num &amp;lt;= 107   1 2 3 4 5 6 7 8 9  func convertToBase7(num int) string { if num &amp;lt; 0 { return &amp;#34;-&amp;#34; + convertToBase7(-num) } if num &amp;lt; 7 { return strconv.Itoa(num) } return convertToBase7(num/7) + strconv.</description>
    </item>
    
    <item>
      <title>509 Fibonacci Number</title>
      <link>https://blog.siwei.dev/leetcode/509-fibonacci-number/</link>
      <pubDate>Sun, 19 Sep 2021 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/509-fibonacci-number/</guid>
      <description>The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is,
F(0) = 0, F(1) = 1 F(n) = F(n - 1) + F(n - 2), for n &amp;gt; 1. Given n, calculate F(n).
Example 1:
Input: n = 2 Output: 1 Explanation: F(2) = F(1) + F(0) = 1 + 0 = 1.</description>
    </item>
    
    <item>
      <title>525 Contiguous Array</title>
      <link>https://blog.siwei.dev/leetcode/525-contiguous-array/</link>
      <pubDate>Sat, 27 Mar 2021 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/525-contiguous-array/</guid>
      <description>Given a binary array, find the maximum length of a contiguous subarray with equal number of 0 and 1.
Example 1:
Input: [0,1] Output: 2 Explanation: [0, 1] is the longest contiguous subarray with equal number of 0 and 1. Example 2:
Input: [0,1,0] Output: 2 Explanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1. Note: The length of the given binary array will not exceed 50,000.</description>
    </item>
    
    <item>
      <title>557 Reverse Words in a String III</title>
      <link>https://blog.siwei.dev/leetcode/557-reverse-words-in-a-string-iii/</link>
      <pubDate>Sun, 19 Sep 2021 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/557-reverse-words-in-a-string-iii/</guid>
      <description>Given a string s, reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.
Example 1:
Input: s = &amp;quot;Let&#39;s take LeetCode contest&amp;quot; Output: &amp;quot;s&#39;teL ekat edoCteeL tsetnoc&amp;quot; Example 2:
Input: s = &amp;quot;God Ding&amp;quot; Output: &amp;quot;doG gniD&amp;quot; Constraints:
 1 &amp;lt;= s.length &amp;lt;= 5 * 104 s contains printable ASCII characters. s does not contain any leading or trailing spaces. There is at least one word in s.</description>
    </item>
    
    <item>
      <title>566 Reshape the Matrix</title>
      <link>https://blog.siwei.dev/leetcode/566-reshape-the-matrix/</link>
      <pubDate>Thu, 30 Sep 2021 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/566-reshape-the-matrix/</guid>
      <description>In MATLAB, there is a handy function called reshape which can reshape an m x n matrix into a new one with a different size r x c keeping its original data.
You are given an m x n matrix mat and two integers r and c representing the number of rows and the number of columns of the wanted reshaped matrix.
The reshaped matrix should be filled with all the elements of the original matrix in the same row-traversing order as they were.</description>
    </item>
    
    <item>
      <title>567 Permutation in String</title>
      <link>https://blog.siwei.dev/leetcode/567-permutation-in-string/</link>
      <pubDate>Sun, 19 Sep 2021 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/567-permutation-in-string/</guid>
      <description>Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.
In other words, return true if one of s1&amp;rsquo;s permutations is the substring of s2.
Example 1:
Input: s1 = &amp;quot;ab&amp;quot;, s2 = &amp;quot;eidbaooo&amp;quot; Output: true Explanation: s2 contains one permutation of s1 (&amp;quot;ba&amp;quot;). Example 2:
Input: s1 = &amp;quot;ab&amp;quot;, s2 = &amp;quot;eidboaoo&amp;quot; Output: false Constraints:
 1 &amp;lt;= s1.length, s2.length &amp;lt;= 104 s1 and s2 consist of lowercase English letters.</description>
    </item>
    
    <item>
      <title>617 Merge Two Binary Trees</title>
      <link>https://blog.siwei.dev/leetcode/617-merge-two-binary-trees/</link>
      <pubDate>Thu, 23 Sep 2021 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/617-merge-two-binary-trees/</guid>
      <description>You are given two binary trees root1 and root2.
Imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree.</description>
    </item>
    
    <item>
      <title>695 Max Area of Island</title>
      <link>https://blog.siwei.dev/leetcode/695-max-area-of-island/</link>
      <pubDate>Thu, 23 Sep 2021 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/695-max-area-of-island/</guid>
      <description>You are given an m x n binary matrix grid. An island is a group of 1&amp;rsquo;s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.
The area of an island is the number of cells with a value 1 in the island.
Return the maximum area of an island in grid. If there is no island, return 0.</description>
    </item>
    
    <item>
      <title>700 Search in a Binary Search Tree</title>
      <link>https://blog.siwei.dev/leetcode/700-search-in-a-binary-search-tree/</link>
      <pubDate>Fri, 01 Oct 2021 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/700-search-in-a-binary-search-tree/</guid>
      <description>You are given the root of a binary search tree (BST) and an integer val.
Find the node in the BST that the node&amp;rsquo;s value equals val and return the subtree rooted with that node. If such a node does not exist, return null.
Example 1:
 4 / \ (2) 7 / \ (1) (3) Input: root = [4,2,7,1,3], val = 2 Output: [2,1,3] Example 2:
 4 / \ 2 7 / \ 1 3 Input: root = [4,2,7,1,3], val = 5 Output: [] Constraints:</description>
    </item>
    
    <item>
      <title>701 Insert into a Binary Search Tree</title>
      <link>https://blog.siwei.dev/leetcode/701-insert-into-a-binary-search-tree/</link>
      <pubDate>Sat, 02 Oct 2021 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/701-insert-into-a-binary-search-tree/</guid>
      <description>You are given the root node of a binary search tree (BST) and a value to insert into the tree. Return the root node of the BST after the insertion. It is guaranteed that the new value does not exist in the original BST.
Notice that there may exist multiple valid ways for the insertion, as long as the tree remains a BST after insertion. You can return any of them.</description>
    </item>
    
    <item>
      <title>704 Binary Search</title>
      <link>https://blog.siwei.dev/leetcode/704-binary-search/</link>
      <pubDate>Sat, 18 Sep 2021 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/704-binary-search/</guid>
      <description>Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.
You must write an algorithm with O(log n) runtime complexity.
Example 1:
Input: nums = [-1,0,3,5,9,12], target = 9 Output: 4 Explanation: 9 exists in nums and its index is 4 Example 2:
Input: nums = [-1,0,3,5,9,12], target = 2 Output: -1 Explanation: 2 does not exist in nums so return -1 Constraints:</description>
    </item>
    
    <item>
      <title>733 Flood Fill</title>
      <link>https://blog.siwei.dev/leetcode/733-flood-fill/</link>
      <pubDate>Thu, 23 Sep 2021 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/733-flood-fill/</guid>
      <description>An image is represented by an m x n integer grid image where image[i][j] represents the pixel value of the image.
You are also given three integers sr, sc, and newColor. You should perform a flood fill on the image starting from the pixel image[sr][sc].
To perform a flood fill, consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color), and so on.</description>
    </item>
    
    <item>
      <title>876 Middle of the Linked List</title>
      <link>https://blog.siwei.dev/leetcode/876-middle-of-the-linked-list/</link>
      <pubDate>Sun, 19 Sep 2021 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/876-middle-of-the-linked-list/</guid>
      <description>Given the head of a singly linked list, return the middle node of the linked list.
If there are two middle nodes, return the second middle node.
Example 1:
1 -&amp;gt; 2 -&amp;gt; (3) -&amp;gt; 4 -&amp;gt; 5 Input: head = [1,2,3,4,5] Output: [3,4,5] Explanation: The middle node of the list is node 3. Example 2:
1 -&amp;gt; 2 -&amp;gt; 3 -&amp;gt; (4) -&amp;gt; 5 -&amp;gt; 6 Input: head = [1,2,3,4,5,6] Output: [4,5,6] Explanation: Since the list has two middle nodes with values 3 and 4, we return the second one.</description>
    </item>
    
    <item>
      <title>977 Squares of a Sorted Array</title>
      <link>https://blog.siwei.dev/leetcode/977-squares-of-a-sorted-array/</link>
      <pubDate>Sat, 18 Sep 2021 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/977-squares-of-a-sorted-array/</guid>
      <description>Given an integer array nums sorted in non-decreasing order, return an array of the squares of each number sorted in non-decreasing order.
Example 1:
Input: nums = [-4,-1,0,3,10] Output: [0,1,9,16,100] Explanation: After squaring, the array becomes [16,1,0,9,100]. After sorting, it becomes [0,1,9,16,100]. Example 2:
Input: nums = [-7,-3,2,3,11] Output: [4,9,9,49,121] Constraints:
 1 &amp;lt;= nums.length &amp;lt;= 104 -104 &amp;lt;= nums[i] &amp;lt;= 104 nums is sorted in non-decreasing order.  Follow up: Squaring each element and sorting the new array is very trivial, could you find an O(n) solution using a different approach?</description>
    </item>
    
    <item>
      <title>1022 Sum of Root To Leaf Binary Numbers</title>
      <link>https://blog.siwei.dev/leetcode/1022-sum-of-root-to-leaf-binary-numbers/</link>
      <pubDate>Wed, 24 Mar 2021 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/1022-sum-of-root-to-leaf-binary-numbers/</guid>
      <description>You are given the root of a binary tree where each node has a value 0 or 1. Each root-to-leaf path represents a binary number starting with the most significant bit. For example, if the path is 0 -&amp;gt; 1 -&amp;gt; 1 -&amp;gt; 0 -&amp;gt; 1, then this could represent 01101 in binary, which is 13.
For all leaves in the tree, consider the numbers represented by the path from the root to that leaf.</description>
    </item>
    
    <item>
      <title>1114 Print in Order</title>
      <link>https://blog.siwei.dev/leetcode/1114-print-in-order/</link>
      <pubDate>Mon, 22 Mar 2021 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/1114-print-in-order/</guid>
      <description>Suppose we have a class:
public class Foo { public void first() { print(&amp;quot;first&amp;quot;); } public void second() { print(&amp;quot;second&amp;quot;); } public void third() { print(&amp;quot;third&amp;quot;); } } The same instance of Foo will be passed to three different threads. Thread A will call first(), thread B will call second(), and thread C will call third(). Design a mechanism and modify the program to ensure that second() is executed after first(), and third() is executed after second().</description>
    </item>
    
    <item>
      <title>1137 N-th Tribonacci Number</title>
      <link>https://blog.siwei.dev/leetcode/1137-n-th-tribonacci-number/</link>
      <pubDate>Sun, 19 Sep 2021 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/1137-n-th-tribonacci-number/</guid>
      <description>The Tribonacci sequence Tn is defined as follows:
T0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n &amp;gt;= 0.
Given n, return the value of Tn.
Example 1:
Input: n = 4 Output: 4 Explanation: T_3 = 0 + 1 + 1 = 2 T_4 = 1 + 1 + 2 = 4 Example 2:
Input: n = 25 Output: 1389537 Constraints:</description>
    </item>
    
    <item>
      <title>1325 Delete Leaves With a Given Value</title>
      <link>https://blog.siwei.dev/leetcode/1325-delete-leaves-with-a-given-value/</link>
      <pubDate>Sun, 28 Mar 2021 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/1325-delete-leaves-with-a-given-value/</guid>
      <description>Given a binary tree root and an integer target, delete all the leaf nodes with value target.
Note that once you delete a leaf node with value target, if it&amp;rsquo;s parent node becomes a leaf node and has the value target, it should also be deleted (you need to continue doing that until you can&amp;rsquo;t).
Example 1:
 1 1 1 / \ / \ \ 2 3 =&amp;gt; (2) 3 =&amp;gt; 3 / / \ \ \ (2) (2) 4 4 4 Input: root = [1,2,3,2,null,2,4], target = 2 Output: [1,null,3,null,4] Explanation: Leaf nodes in green with value (target = 2) are removed (Picture in left).</description>
    </item>
    
    <item>
      <title>1413 Minimum Value to Get Positive Step by Step Sum</title>
      <link>https://blog.siwei.dev/leetcode/1413-minimum-value-to-get-positive-step-by-step-sum/</link>
      <pubDate>Sun, 28 Mar 2021 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/1413-minimum-value-to-get-positive-step-by-step-sum/</guid>
      <description>Given an array of integers nums, you start with an initial positive value startValue.
In each iteration, you calculate the step by step sum of startValue plus elements in nums (from left to right).
Return the minimum positive value of startValue such that the step by step sum is never less than 1.
Example 1:
Input: nums = [-3,2,-3,4,2] Output: 5 Explanation: If you choose startValue = 4, in the third iteration your step by step sum is less than 1.</description>
    </item>
    
    <item>
      <title>Autoscale Policy</title>
      <link>https://blog.siwei.dev/leetcode/autoscale-policy/</link>
      <pubDate>Sun, 17 Oct 2021 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/autoscale-policy/</guid>
      <description>Given an integer, instances, and an array, arr[] of size N representing the average utilization percentage of the computing system at each second, the task is to find the number of instances at the end of the time frame such that the computing system auto-scales the number of instances according to the following rules:
 Average utilization &amp;lt; 25%: Reduce the number of instances by half if the number of instances is greater than 1.</description>
    </item>
    
  </channel>
</rss>
