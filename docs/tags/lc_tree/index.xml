<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>lc_tree on Siwei&#39;s Blog</title>
    <link>https://blog.siwei.dev/tags/lc_tree/</link>
    <description>Recent content in lc_tree on Siwei&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 02 Oct 2021 00:00:00 -0400</lastBuildDate><atom:link href="https://blog.siwei.dev/tags/lc_tree/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>94 Binary Tree Inorder Traversal</title>
      <link>https://blog.siwei.dev/leetcode/94-binary-tree-inorder-traversal/</link>
      <pubDate>Sat, 02 Oct 2021 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/94-binary-tree-inorder-traversal/</guid>
      <description>Given the root of a binary tree, return the inorder traversal of its nodes&amp;rsquo; values.
Example 1:
1\2/3Input: root = [1,null,2,3]Output: [1,3,2] Example 2:
Input: root = []Output: [] Example 3:
Input: root = [1]Output: [1] Example 4:
1/2Input: root = [1,2]Output: [2,1] Example 5:
1\2Input: root = [1,null,2]Output: [1,2] Constraints:
The number of nodes in the tree is in the range [0, 100].</description>
    </item>
    
    <item>
      <title>100 Same Tree</title>
      <link>https://blog.siwei.dev/leetcode/100-same-tree/</link>
      <pubDate>Wed, 09 Jun 2021 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/100-same-tree/</guid>
      <description>Given the roots of two binary trees p and q, write a function to check if they are the same or not.
Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.
Example 1:
1 1/ \ / \2 3 2 3Input: p = [1,2,3], q = [1,2,3]Output: true Example 2:
1 1/ \2 2Input: p = [1,2], q = [1,null,2]Output: false Example 3:</description>
    </item>
    
    <item>
      <title>101 Symmetric Tree</title>
      <link>https://blog.siwei.dev/leetcode/101-symmetric-tree/</link>
      <pubDate>Sat, 20 Mar 2021 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/101-symmetric-tree/</guid>
      <description>Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).
Example 1:
1/ \2 2/ \ / \3 4 4 3Input: root = [1,2,2,3,4,4,3]Output: true Example 2:
1/ \2 2\ \3 3Input: root = [1,2,2,null,3,null,3]Output: false Constraints:
The number of nodes in the tree is in the range [1, 1000].</description>
    </item>
    
    <item>
      <title>102 Binary Tree Level Order Traversal</title>
      <link>https://blog.siwei.dev/leetcode/102-binary-tree-level-order-traversal/</link>
      <pubDate>Sat, 02 Oct 2021 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/102-binary-tree-level-order-traversal/</guid>
      <description>Given the root of a binary tree, return the level order traversal of its nodes&amp;rsquo; values. (i.e., from left to right, level by level).
Example 1:
3/ \9 20/ \15 7Input: root = [3,9,20,null,null,15,7]Output: [[3],[9,20],[15,7]] Example 2:
Input: root = [1]Output: [[1]] Example 3:
Input: root = []Output: [] Constraints:
The number of nodes in the tree is in the range [0, 2000].</description>
    </item>
    
    <item>
      <title>103 Binary Tree Zigzag Level Order Traversal</title>
      <link>https://blog.siwei.dev/leetcode/103-binary-tree-zigzag-level-order-traversal/</link>
      <pubDate>Sun, 21 Mar 2021 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/103-binary-tree-zigzag-level-order-traversal/</guid>
      <description>Given the root of a binary tree, return the zigzag level order traversal of its nodes&amp;rsquo; values. (i.e., from left to right, then right to left for the next level and alternate between).
Example 1:
3/ \9 20/ \15 7Input: root = [3,9,20,null,null,15,7]Output: [[3],[20,9],[15,7]] Example 2:
Input: root = [1]Output: [[1]] Example 3:
Input: root = []Output: [] Constraints:
The number of nodes in the tree is in the range [0, 2000].</description>
    </item>
    
    <item>
      <title>104 Maximum Depth of Binary Tree</title>
      <link>https://blog.siwei.dev/leetcode/104-maximum-depth-of-binary-tree/</link>
      <pubDate>Sat, 02 Oct 2021 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/104-maximum-depth-of-binary-tree/</guid>
      <description>Given the root of a binary tree, return its maximum depth.
A binary tree&amp;rsquo;s maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.
Example 1:
3/ \9 20/ \15 7Input: root = [3,9,20,null,null,15,7]Output: 3 Example 2:
Input: root = [1,null,2]Output: 2 Example 3:
Input: root = []Output: 0 Example 4:</description>
    </item>
    
    <item>
      <title>109 Convert Sorted List to Binary Search Tree</title>
      <link>https://blog.siwei.dev/leetcode/109-convert-sorted-list-to-binary-search-tree/</link>
      <pubDate>Sun, 21 Mar 2021 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/109-convert-sorted-list-to-binary-search-tree/</guid>
      <description>Given the head of a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.
For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.
Example 1:
-10 -&amp;gt; -3 -&amp;gt; 0 -&amp;gt; 5 -&amp;gt; 90 0/ \ / \-10 5 or -3 9\ \ / /-3 9 -10 5Input: head = [-10,-3,0,5,9]Output: [0,-3,9,-10,null,5]Explanation: One possible answer is [0,-3,9,-10,null,5], which represents the shown height balanced BST.</description>
    </item>
    
    <item>
      <title>112 Path Sum</title>
      <link>https://blog.siwei.dev/leetcode/112-path-sum/</link>
      <pubDate>Sat, 02 Oct 2021 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/112-path-sum/</guid>
      <description>Given the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum.
A leaf is a node with no children.
Example 1:
5/ \4 8/ / \11 13 4/ \ \7 2 1Input: root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22Output: true Example 2:</description>
    </item>
    
    <item>
      <title>113 Path Sum II</title>
      <link>https://blog.siwei.dev/leetcode/113-path-sum-ii/</link>
      <pubDate>Thu, 25 Mar 2021 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/113-path-sum-ii/</guid>
      <description>Given the root of a binary tree and an integer targetSum, return all root-to-leaf paths where each path&amp;rsquo;s sum equals targetSum.
A leaf is a node with no children.
Example 1:
5/ \4 8/ / \11 13 4/ \ / \7 2 5 1Input: root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22Output: [[5,4,11,2],[5,8,4,5]] Example 2:
1/ \2 3Input: root = [1,2,3], targetSum = 5Output: [] Example 3:</description>
    </item>
    
    <item>
      <title>144 Binary Tree Preorder Traversal</title>
      <link>https://blog.siwei.dev/leetcode/144-binary-tree-preorder-traversal/</link>
      <pubDate>Sat, 02 Oct 2021 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/144-binary-tree-preorder-traversal/</guid>
      <description>Given the root of a binary tree, return the preorder traversal of its nodes&amp;rsquo; values.
Example 1:
1\2/3Input: root = [1,null,2,3]Output: [1,2,3] Example 2:
Input: root = []Output: [] Example 3:
Input: root = [1]Output: [1] Example 4:
1/2Input: root = [1,2]Output: [1,2] Example 5:
1\2Input: root = [1,null,2]Output: [1,2] Constraints:
The number of nodes in the tree is in the range [0, 100].</description>
    </item>
    
    <item>
      <title>145 Binary Tree Postorder Traversal</title>
      <link>https://blog.siwei.dev/leetcode/145-binary-tree-postorder-traversal/</link>
      <pubDate>Sat, 02 Oct 2021 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/145-binary-tree-postorder-traversal/</guid>
      <description>Given the root of a binary tree, return the postorder traversal of its nodes&amp;rsquo; values.
Example 1:
1\2/3Input: root = [1,null,2,3]Output: [3,2,1] Example 2:
Input: root = []Output: [] Example 3:
Input: root = [1]Output: [1] Example 4:
1/2Input: root = [1,2]Output: [2,1] Example 5:
1\2Input: root = [1,null,2]Output: [2,1] Constraints:
The number of nodes in the tree is in the range [0, 100].</description>
    </item>
    
    <item>
      <title>226 Invert Binary Tree</title>
      <link>https://blog.siwei.dev/leetcode/226-invert-binary-tree/</link>
      <pubDate>Sat, 02 Oct 2021 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/226-invert-binary-tree/</guid>
      <description>Given the root of a binary tree, invert the tree, and return its root.
Example 1:
4 4/ \ / \2 7 =&amp;gt; 7 2/ \ / \ / \ / \1 3 6 9 1 3 6 9Input: root = [4,2,7,1,3,6,9]Output: [4,7,2,9,6,3,1] Example 2:
2 2/ \ =&amp;gt; / \1 3 3 1Input: root = [2,1,3]Output: [2,3,1] Example 3:</description>
    </item>
    
    <item>
      <title>235 Lowest Common Ancestor of a Binary Search Tree</title>
      <link>https://blog.siwei.dev/leetcode/235-lowest-common-ancestor-of-a-binary-search-tree/</link>
      <pubDate>Sat, 02 Oct 2021 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/235-lowest-common-ancestor-of-a-binary-search-tree/</guid>
      <description>Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.
According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”
Example 1:
6/ \2 8/ \ / \0 4 7 9/ \3 5Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8Output: 6Explanation: The LCA of nodes 2 and 8 is 6.</description>
    </item>
    
    <item>
      <title>617 Merge Two Binary Trees</title>
      <link>https://blog.siwei.dev/leetcode/617-merge-two-binary-trees/</link>
      <pubDate>Thu, 23 Sep 2021 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/617-merge-two-binary-trees/</guid>
      <description>You are given two binary trees root1 and root2.
Imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree.</description>
    </item>
    
    <item>
      <title>700 Search in a Binary Search Tree</title>
      <link>https://blog.siwei.dev/leetcode/700-search-in-a-binary-search-tree/</link>
      <pubDate>Fri, 01 Oct 2021 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/700-search-in-a-binary-search-tree/</guid>
      <description>You are given the root of a binary search tree (BST) and an integer val.
Find the node in the BST that the node&amp;rsquo;s value equals val and return the subtree rooted with that node. If such a node does not exist, return null.
Example 1:
4/ \(2) 7/ \(1) (3)Input: root = [4,2,7,1,3], val = 2Output: [2,1,3] Example 2:
4/ \2 7/ \1 3Input: root = [4,2,7,1,3], val = 5Output: [] Constraints:</description>
    </item>
    
    <item>
      <title>701 Insert into a Binary Search Tree</title>
      <link>https://blog.siwei.dev/leetcode/701-insert-into-a-binary-search-tree/</link>
      <pubDate>Sat, 02 Oct 2021 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/701-insert-into-a-binary-search-tree/</guid>
      <description>You are given the root node of a binary search tree (BST) and a value to insert into the tree. Return the root node of the BST after the insertion. It is guaranteed that the new value does not exist in the original BST.
Notice that there may exist multiple valid ways for the insertion, as long as the tree remains a BST after insertion. You can return any of them.</description>
    </item>
    
    <item>
      <title>1022 Sum of Root To Leaf Binary Numbers</title>
      <link>https://blog.siwei.dev/leetcode/1022-sum-of-root-to-leaf-binary-numbers/</link>
      <pubDate>Wed, 24 Mar 2021 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/1022-sum-of-root-to-leaf-binary-numbers/</guid>
      <description>You are given the root of a binary tree where each node has a value 0 or 1. Each root-to-leaf path represents a binary number starting with the most significant bit. For example, if the path is 0 -&amp;gt; 1 -&amp;gt; 1 -&amp;gt; 0 -&amp;gt; 1, then this could represent 01101 in binary, which is 13.
For all leaves in the tree, consider the numbers represented by the path from the root to that leaf.</description>
    </item>
    
    <item>
      <title>1325 Delete Leaves With a Given Value</title>
      <link>https://blog.siwei.dev/leetcode/1325-delete-leaves-with-a-given-value/</link>
      <pubDate>Sun, 28 Mar 2021 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/1325-delete-leaves-with-a-given-value/</guid>
      <description>Given a binary tree root and an integer target, delete all the leaf nodes with value target.
Note that once you delete a leaf node with value target, if it&amp;rsquo;s parent node becomes a leaf node and has the value target, it should also be deleted (you need to continue doing that until you can&amp;rsquo;t).
Example 1:
1 1 1/ \ / \ \2 3 =&amp;gt; (2) 3 =&amp;gt; 3/ / \ \ \(2) (2) 4 4 4Input: root = [1,2,3,2,null,2,4], target = 2Output: [1,null,3,null,4]Explanation: Leaf nodes in green with value (target = 2) are removed (Picture in left).</description>
    </item>
    
  </channel>
</rss>
