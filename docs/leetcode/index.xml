<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Leetcodes on Siwei&#39;s Blog</title>
    <link>https://blog.siwei.dev/leetcode/</link>
    <description>Recent content in Leetcodes on Siwei&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 20 Dec 2020 00:00:00 +0800</lastBuildDate><atom:link href="https://blog.siwei.dev/leetcode/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>1 Two Sum</title>
      <link>https://blog.siwei.dev/leetcode/1-two-sum/</link>
      <pubDate>Mon, 21 Sep 2020 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/1-two-sum/</guid>
      <description>Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.
You may assume that each input would have exactly one solution, and you may not use the same element twice.
You can return the answer in any order.
Example 1:
Input: nums = [2,7,11,15], target = 9Output: [0,1]Output: Because nums[0] + nums[1] == 9, we return [0, 1].</description>
    </item>
    
    <item>
      <title>2 Add Two Numbers</title>
      <link>https://blog.siwei.dev/leetcode/2-add-two-numbers/</link>
      <pubDate>Mon, 21 Sep 2020 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/2-add-two-numbers/</guid>
      <description>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.
You may assume the two numbers do not contain any leading zero, except the number 0 itself.
Example:
Input: (2 -&amp;gt; 4 -&amp;gt; 3) + (5 -&amp;gt; 6 -&amp;gt; 4)Output: 7 -&amp;gt; 0 -&amp;gt; 8Explanation: 342 + 465 = 807.</description>
    </item>
    
    <item>
      <title>4 Median of Two Sorted Arrays</title>
      <link>https://blog.siwei.dev/leetcode/4-median-of-two-sorted-arrays/</link>
      <pubDate>Sat, 24 Oct 2020 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/4-median-of-two-sorted-arrays/</guid>
      <description>Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.
Follow up: The overall run time complexity should be O(log (m+n)).
Example 1:
Input: nums1 = [1,3], nums2 = [2]Output: 2.00000Explanation: merged array = [1,2,3] and median is 2.Example 2:
Input: nums1 = [1,2], nums2 = [3,4]Output: 2.50000Explanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.</description>
    </item>
    
    <item>
      <title>5 Longest Palindromic Substring</title>
      <link>https://blog.siwei.dev/leetcode/5-longest-palindromic-substring/</link>
      <pubDate>Wed, 23 Sep 2020 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/5-longest-palindromic-substring/</guid>
      <description>Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.
Example1:
Input: &amp;quot;babad&amp;quot;Output: &amp;quot;bab&amp;quot;Note: &amp;quot;aba&amp;quot; is also a valid answer.Example2:
Input: &amp;quot;cbbd&amp;quot;Output: &amp;quot;bb&amp;quot;1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  func longestPalindrome(s string) string { if len(s) &amp;lt; 1 { return &amp;#34;&amp;#34; } start := 0 end := 0 for i := range s { len1 := expandAroundCenter(s, i, i) len2 := expandAroundCenter(s, i, i+1) lenMax := -1 if len1 &amp;gt; len2 { lenMax = len1 } else { lenMax = len2 } if lenMax &amp;gt; end-start+1 { start = i - (lenMax-1)/2 end = i + lenMax/2 } } return s[start : end+1] } func expandAroundCenter(s string, left int, right int) int { for left &amp;gt;= 0 &amp;amp;&amp;amp; right &amp;lt; len(s) &amp;amp;&amp;amp; s[left] == s[right] { left-- right++ } return right - left - 1 }   https://runtime.</description>
    </item>
    
    <item>
      <title>20 Valid Parentheses</title>
      <link>https://blog.siwei.dev/leetcode/20-valid-parentheses/</link>
      <pubDate>Fri, 25 Sep 2020 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/20-valid-parentheses/</guid>
      <description>Given a string s containing just the characters &#39;(&#39;, &#39;)&#39;, &#39;{&#39;, &#39;}&#39;, &#39;[&#39; and &#39;]&#39;, determine if the input string is valid.
An input string is valid if:
 Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order.  Example 1:
Input: s = &amp;quot;()&amp;quot;Output: trueExample 2:
Input: s = &amp;quot;()[]{}&amp;quot;Output: trueExample 3:
Input: s = &amp;quot;(]&amp;quot;Output: falseExample 4:</description>
    </item>
    
    <item>
      <title>21 Merge Two Sorted Lists</title>
      <link>https://blog.siwei.dev/leetcode/21-merge-two-sorted-lists/</link>
      <pubDate>Sun, 18 Oct 2020 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/21-merge-two-sorted-lists/</guid>
      <description>Merge two sorted linked lists and return it as a new sorted list. The new list should be made by splicing together the nodes of the first two lists.
Example 1:
Input: l1 = [1,2,4], l2 = [1,3,4]Output: [1,1,2,3,4,4]Example 2:
Input: l1 = [], l2 = []Output: []Example 3:
Input: l1 = [], l2 = [0]Output: [0]Constraints:
 The number of nodes in both lists is in the range [0, 50].</description>
    </item>
    
    <item>
      <title>122 Best Time to Buy and Sell Stock II</title>
      <link>https://blog.siwei.dev/leetcode/122-best-time-to-buy-and-sell-stock-ii/</link>
      <pubDate>Sun, 25 Oct 2020 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/122-best-time-to-buy-and-sell-stock-ii/</guid>
      <description>Say you have an array prices for which the ith element is the price of a given stock on day i.
Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).
Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).</description>
    </item>
    
    <item>
      <title>136 Single Number</title>
      <link>https://blog.siwei.dev/leetcode/136-single-number/</link>
      <pubDate>Sat, 26 Sep 2020 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/136-single-number/</guid>
      <description>Given a non-empty array of integers, every element appears twice except for one. Find that single one.
Note:
Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?
Example 1:
Input: [2,2,1]Output: 1Example 2:
Input: [4,1,2,1,2]Output: 41 2 3 4 5 6 7 8 9 10 11 12 13 14  func singleNumber(nums []int) int { set := make(map[int]bool) for _, num := range nums { if _, ok := set[num]; ok { delete(set, num) } else { set[num] = true } } for num, _ := range set { return num } return -1 }   https://runtime.</description>
    </item>
    
    <item>
      <title>200 Number of Islands</title>
      <link>https://blog.siwei.dev/leetcode/200-number-of-islands/</link>
      <pubDate>Thu, 10 Dec 2020 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/200-number-of-islands/</guid>
      <description>Given an m x n 2d grid map of &#39;1&#39;s (land) and &#39;0&#39;s (water), return the number of islands.
An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.
Example 1:
Input: grid = [[&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;],[&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;],[&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;],[&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;]]Output: 1Example 2:
Input: grid = [[&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;],[&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;],[&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;],[&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;]]Output: 3Constraints:</description>
    </item>
    
    <item>
      <title>231 Power of Two</title>
      <link>https://blog.siwei.dev/leetcode/231-power-of-two/</link>
      <pubDate>Tue, 20 Oct 2020 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/231-power-of-two/</guid>
      <description>Given an integer n, write a function to determine if it is a power of two.
Example 1:
Input: n = 1Output: trueExplanation: 20 = 1Example 2:
Input: n = 16Output: trueExplanation: 24 = 16Example 3:
Input: n = 3Output: falseExample 4:
Input: n = 4Output: trueExample 5:
Input: n = 5Output: falseConstraints:
 -231 &amp;lt;= n &amp;lt;= 231 - 1  1 2 3 4 5 6 7  func isPowerOfTwo(n int) bool { i := 1 for i &amp;lt; n { i *= 2 } return i == n }   https://runtime.</description>
    </item>
    
    <item>
      <title>242 Valid Anagram</title>
      <link>https://blog.siwei.dev/leetcode/242-valid-anagram/</link>
      <pubDate>Thu, 10 Dec 2020 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/242-valid-anagram/</guid>
      <description>Given two strings s and t , write a function to determine if t is an anagram of s.
Example 1:
Input: s = &amp;quot;anagram&amp;quot;, t = &amp;quot;nagaram&amp;quot;Output: trueExample 2:
Input: s = &amp;quot;rat&amp;quot;, t = &amp;quot;car&amp;quot;Output: falseNote: You may assume the string contains only lowercase alphabets.
Follow up: What if the inputs contain unicode characters? How would you adapt your solution to such case?
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  func isAnagram(s string, t string) bool { if len(s) !</description>
    </item>
    
    <item>
      <title>344 Reverse String</title>
      <link>https://blog.siwei.dev/leetcode/344-reverse-string/</link>
      <pubDate>Tue, 20 Oct 2020 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/344-reverse-string/</guid>
      <description>Write a function that reverses a string. The input string is given as an array of characters char[].
Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.
You may assume all the characters consist of printable ascii characters.
Example 1:
Input: [&amp;quot;h&amp;quot;,&amp;quot;e&amp;quot;,&amp;quot;l&amp;quot;,&amp;quot;l&amp;quot;,&amp;quot;o&amp;quot;]Output: [&amp;quot;o&amp;quot;,&amp;quot;l&amp;quot;,&amp;quot;l&amp;quot;,&amp;quot;e&amp;quot;,&amp;quot;h&amp;quot;]Example 2:
Input: [&amp;quot;H&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;n&amp;quot;,&amp;quot;n&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;h&amp;quot;]Output: [&amp;quot;h&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;n&amp;quot;,&amp;quot;n&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;H&amp;quot;]1 2 3 4 5 6 7 8 9 10 11  func reverseString(s []byte]) { i , j := 0, len(s) - 1 for i &amp;lt; j { temp := s[i] s[i] = s[j] i++ s[j] = temp j-- } fmt.</description>
    </item>
    
    <item>
      <title>387 First Unique Character in a String</title>
      <link>https://blog.siwei.dev/leetcode/387-first-unique-character-in-a-string/</link>
      <pubDate>Sun, 20 Dec 2020 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/387-first-unique-character-in-a-string/</guid>
      <description>Given a string, find the first non-repeating character in it and return its index. If it doesn&amp;rsquo;t exist, return -1.
Examples:
s = &amp;quot;leetcode&amp;quot;return 0.s = &amp;quot;loveleetcode&amp;quot;return 2.Note: You may assume the string contains only lowercase English letters.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  func firstUniqChar(s string) int { m := make(map[rune]int) for i, c := range s { _, has := m[c] if has { m[c] = -1 } else { m[c] = i } } const maxInt = int(^uint(0) &amp;gt;&amp;gt; 1) min := maxInt for _, i := range m { if i &amp;gt; -1 &amp;amp;&amp;amp; i &amp;lt; min { min = i } } if min == maxInt { return -1 } return min }   </description>
    </item>
    
    <item>
      <title>400 Nth Digit</title>
      <link>https://blog.siwei.dev/leetcode/400-nth-digit/</link>
      <pubDate>Wed, 28 Oct 2020 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/400-nth-digit/</guid>
      <description>Find the nth digit of the infinite integer sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, &amp;hellip;
Note: n is positive and will fit within the range of a 32-bit signed integer (n &amp;lt; 231).
Example 1:
Input:3Output:3Example 2:
Input:11Output:0Explanation:The 11th digit of the sequence1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ...is a 0, which is part of the number 10.</description>
    </item>
    
    <item>
      <title>412 Fizz Buzz</title>
      <link>https://blog.siwei.dev/leetcode/412-fizz-buzz/</link>
      <pubDate>Thu, 24 Sep 2020 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/412-fizz-buzz/</guid>
      <description>Write a program that outputs the string representation of numbers from 1 to n.
But for multiples of three it should output “Fizz” instead of the number and for the multiples of five output “Buzz”. For numbers which are multiples of both three and five output “FizzBuzz”.
Example:
n = 15,Return:[&amp;quot;1&amp;quot;,&amp;quot;2&amp;quot;,&amp;quot;Fizz&amp;quot;,&amp;quot;4&amp;quot;,&amp;quot;Buzz&amp;quot;,&amp;quot;Fizz&amp;quot;,&amp;quot;7&amp;quot;,&amp;quot;8&amp;quot;,&amp;quot;Fizz&amp;quot;,&amp;quot;Buzz&amp;quot;,&amp;quot;11&amp;quot;,&amp;quot;Fizz&amp;quot;,&amp;quot;13&amp;quot;,&amp;quot;14&amp;quot;,&amp;quot;FizzBuzz&amp;quot;]1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  func fizzBuzz(n int) []string { var result []string for i := 1; i &amp;lt;= n; i++ { if i%3 == 0 &amp;amp;&amp;amp; i%5 == 0 { result = append(result, &amp;#34;FizzBuzz&amp;#34;) } else if i%3 == 0 { result = append(result, &amp;#34;Fizz&amp;#34;) } else if i%5 == 0 { result = append(result, &amp;#34;Buzz&amp;#34;) } else { result = append(result, strconv.</description>
    </item>
    
    <item>
      <title>476 Number Complement</title>
      <link>https://blog.siwei.dev/leetcode/476-number-complement/</link>
      <pubDate>Thu, 10 Dec 2020 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/476-number-complement/</guid>
      <description>Given a positive integer num, output its complement number. The complement strategy is to flip the bits of its binary representation.
Example 1:
Input: num = 5Output: 2Explanation: The binary representation of 5 is 101 (no leading zero bits),and its complement is 010. So you need to output 2.Example 2:
Input: num = 1Output: 0Explanation: The binary representation of 1 is 1 (no leading zero bits),and its complement is 0.</description>
    </item>
    
  </channel>
</rss>
