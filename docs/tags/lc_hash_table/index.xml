<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>lc_hash_table on Siwei&#39;s Blog</title>
    <link>https://blog.siwei.dev/tags/lc_hash_table/</link>
    <description>Recent content in lc_hash_table on Siwei&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 01 Aug 2022 00:00:00 -0400</lastBuildDate><atom:link href="https://blog.siwei.dev/tags/lc_hash_table/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>1 Two Sum</title>
      <link>https://blog.siwei.dev/leetcode/1-two-sum/</link>
      <pubDate>Mon, 21 Sep 2020 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/1-two-sum/</guid>
      <description>Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.
You may assume that each input would have exactly one solution, and you may not use the same element twice.
You can return the answer in any order.
Example 1:
Input: nums = [2,7,11,15], target = 9Output: [0,1]Output: Because nums[0] + nums[1] == 9, we return [0, 1].</description>
    </item>
    
    <item>
      <title>36 Valid Sudoku</title>
      <link>https://blog.siwei.dev/leetcode/36-valid-sudoku/</link>
      <pubDate>Thu, 30 Sep 2021 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/36-valid-sudoku/</guid>
      <description>Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:
Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.
Note:
A Sudoku board (partially filled) could be valid but is not necessarily solvable.</description>
    </item>
    
    <item>
      <title>136 Single Number</title>
      <link>https://blog.siwei.dev/leetcode/136-single-number/</link>
      <pubDate>Sat, 26 Sep 2020 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/136-single-number/</guid>
      <description>Given a non-empty array of integers, every element appears twice except for one. Find that single one.
Note:
Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?
Example 1:
Input: [2,2,1]Output: 1 Example 2:
Input: [4,1,2,1,2]Output: 4 1 2 3 4 5 6 7 8 9 10 11 12 13 14 func singleNumber(nums []int) int { set := make(map[int]bool) for _, num := range nums { if _, ok := set[num]; ok { delete(set, num) } else { set[num] = true } } for num, _ := range set { return num } return -1 } https://runtime.</description>
    </item>
    
    <item>
      <title>146 LRU Cache</title>
      <link>https://blog.siwei.dev/leetcode/146-lru-cache/</link>
      <pubDate>Thu, 30 Sep 2021 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/146-lru-cache/</guid>
      <description>Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.
Implement the LRUCache class:
LRUCache(int capacity) Initialize the LRU cache with positive size capacity. int get(int key) Return the value of the key if the key exists, otherwise return -1. void put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.</description>
    </item>
    
    <item>
      <title>350 Intersection of Two Arrays II</title>
      <link>https://blog.siwei.dev/leetcode/350-intersection-of-two-arrays-ii/</link>
      <pubDate>Thu, 30 Sep 2021 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/350-intersection-of-two-arrays-ii/</guid>
      <description>Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays and you may return the result in any order.
Example 1:
Input: nums1 = [1,2,2,1], nums2 = [2,2]Output: [2,2] Example 2:
Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]Output: [4,9]Explanation: [9,4] is also accepted. Constraints:
1 &amp;lt;= nums1.length, nums2.length &amp;lt;= 1000 0 &amp;lt;= nums1[i], nums2[i] &amp;lt;= 1000 Follow up:</description>
    </item>
    
    <item>
      <title>387 First Unique Character in a String</title>
      <link>https://blog.siwei.dev/leetcode/387-first-unique-character-in-a-string/</link>
      <pubDate>Sun, 20 Dec 2020 00:00:00 +0800</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/387-first-unique-character-in-a-string/</guid>
      <description>Given a string s, find the first non-repeating character in it and return its index. If it does not exist, return -1.
Example 1:
Input: s = &amp;#34;leetcode&amp;#34;Output: 0 Example 2:
Input: s = &amp;#34;loveleetcode&amp;#34;Output: 2 Example 3:
Input: s = &amp;#34;aabb&amp;#34;Output: -1 Constraints:
1 &amp;lt;= s.length &amp;lt;= 105 s consists of only lowercase English letters. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 func firstUniqChar(s string) int { m := make(map[rune]int) for _, c := range s { _, has := m[c] if has { m[c]++ } else { m[c] = 1 } } for i, c := range s { if m[c] == 1 { return i } } return -1 } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution: def firstUniqChar(self, s: str) -&amp;gt; int: count = collections.</description>
    </item>
    
    <item>
      <title>496 Next Greater Element I</title>
      <link>https://blog.siwei.dev/leetcode/496-next-greater-element-i/</link>
      <pubDate>Mon, 01 Aug 2022 00:00:00 -0400</pubDate>
      
      <guid>https://blog.siwei.dev/leetcode/496-next-greater-element-i/</guid>
      <description>The next greater element of some element x in an array is the first greater element that is to the right of x in the same array.
You are given two distinct 0-indexed integer arrays nums1 and nums2, where nums1 is a subset of nums2.
For each 0 &amp;lt;= i &amp;lt; nums1.length, find the index j such that nums1[i] == nums2[j] and determine the next greater element of nums2[j] in nums2.</description>
    </item>
    
  </channel>
</rss>
